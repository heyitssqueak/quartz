{"/":{"title":"emilyyao.me","content":"\n# hey, it's squeak!\nWelcome to my pothole of the internet. I'm Emily! My nickname is \"*squeak*\" — from which most of my usernames on the web are derived. I'm currently a first-year at UW-Madison studying CS. I'm interested in puzzles and robotics, among various other topics like computer networks, competitive coding, and digital privacy. In my free time, I like listening to audiobooks and [copyrighted Nintendo music](https://youtu.be/HL9_xm5HwrE).\n\nI like meeting interesting people! If you want to say hi or grab lunch with me, send a message at `hello` `at` `emilyyao` `dot` `me`!\n\n# pages\n[classes](/academics) | [ubuntu vm](/utm-ubuntu) | [stream](/stream)","lastmodified":"2022-10-14T05:23:27.468421016Z","tags":null},"/2022-sea1":{"title":"Summer Exploration Arc #1","content":"## motivation\nI've always wanted to document my growth over a period of time to see what I can accomplish on my own. This summer is an ideal place to start -- just after high school and before college, where I have enough agency to achieve my goals, without too much academic stress. I'm drawing motivation from this saying: \n\n\u003e Most people overestimate what they can do in a day, but underestimate what they can do in a year.\n\nMy goals are the following:\n- Learn about topics that I think I would enjoy\n- Work on some small projects\n- Build healthy habits\n- Read more, write more\n- Enjoy that summer sun\n\nThey are vague on purpose -- I'll have plenty of options that accomplish these tasks without feeling restricted to a particular path.\n\n## starting point\n### online classes\nBefore the fall semester starts, I want to do a bit of learning on my own. For the most part, I'm going to be reviewing old classes (linear algebra, data structures / algorithms) and exploring new classes (discrete math, artificial intelligence, signals and systems). This is for me to \"test the waters\" and try out things that are interesting to me.\n\n### cool projects\nI'm interested in making something for 3Blue1Brown's [Summer of Math Exposition #2 (SoME2)](https://youtu.be/hZuYICAEN9Y). I'm not particularly sure what knowledge I have to offer but I'm planning on something within the computer science or signal processing realm. \n\nI've also been interested in cybersecurity for the past few months, but never got around to actually learning more about it. Since I have more time now, I want to take advantage of some resources like [HackTheBox](https://hackthebox.com), [OverTheWire: Wargames](https://overthewire.org/wargames/), the [DEF CON CTF archive](https://archive.ooo/) to help me learn more. At the beginning of this year, my goal was to participate in the DEF CON 30 CTF qualifiers, but that has since passed -- my new goal is to take a shot at next year's qualifiers, but we'll see about that...\n\nAmong other things, I want to clean up my website better and get my wiki space set up.\n\n## plan\nMy next update will be in two weeks. For the most part, I want to see where things will take me, so I don't really have a concrete schedule.","lastmodified":"2022-10-14T05:23:27.468421016Z","tags":null},"/2022-sea2":{"title":"Summer Exploration Arc #2","content":"## recap\nI made a [post](/2022-sea1) two weeks ago where I wrote about what I wanted to accomplish in my free time this summer. This is my first progress update.\n\nMy focus has primarily been on settling into a good routine where I can balance work and learning in my downtime. I teach summer camps in the morning which has helped me build a solid morning routine. I have plenty of free time in the afternoons, which I've been trying to put towards doing something useful.\n\n## progress\n### academics\nHistorically, I don't have a good track record when it comes to self-paced online courses -- I struggle a lot with finding an interesting yet not-too-difficult class. So far I've tried and dropped Caltech's [Learning From Data](https://work.caltech.edu/telecourse) course because I didn't understand how to do the homeworks -- the answers were in Python, and I don't know Python. I also gave MIT's [18.06SC: Linear Algebra](https://openlearninglibrary.mit.edu/courses/course-v1:OCW+18.06SC+2T2019/about) a shot, but it's moving along very slowly. I think my hesitancy with this class comes from how I'm not confident at writing proofs. While I enjoy Gilbert Strang's lectures, I blank when it comes to applying new concepts on my own.\n\nGoing back to how I don't know Python: it's been on my todo list for a long time. I never got around to actually *learning* Python, and most of my prior experience came from doing beginner [Advent of Code](https://adventofcode.com/) problems. I did find a course that I've been working through [(CS 220 from UW-Madison)](http://msyamkumar.com/cs220/s20/schedule.html) and I'm about 1/3 of the way through. This has been my main focus for the past week as I've settled into this whole summer exploration thing.\n\n### cybersecurity\nLast week I managed to set up Kali Linux on my laptop after a bit of fiddling around. I'm not sure what I intend to do with it -- so far I've just been trying out the [Linux Fundamentals](https://academy.hackthebox.com/course/preview/linux-fundamentals) course on [HTB Academy](https://academy.hackthebox.com/). I want to get more familiar with using terminal and other command line tools. I also plan to finish a cybersecurity certificate I started a long time ago.\n\n### website\nAfter my last post, I spent a while working on my wiki website which is live now at [wiki.emilyyao.me](https://wiki.emilyyao.me). There are still a few things I need to work out (such as the side TOC being wonky on mobile) but it's a good start. I want to use somehow organize my notes and ramblings into comprehensive pages soon. This project will probably take a while until it is presentable. My main goal is to consistently update this during the school year and create something that can help other people, too.\n\n### \"Enjoy that summer sun\"\nI am sunburnt\n\n### misc\n- [my Taiko addiction](https://youtu.be/QbPj5vfprIQ)\n- Current reads: *Homegoing* by Yaa Gyasi; *Normal People* by Sally Rooney\n\n## plan\nMy first goal is to finish the CS 220 course which might take a bit longer than two weeks. I'd also like to finish both of the books I'm currently reading. Other side goals include: finishing the Linux course with HTB, cleaning up my old calculus notes on my wiki, and exiting my house to do something other than drive to work.","lastmodified":"2022-10-14T05:23:27.468421016Z","tags":null},"/2022-sea3":{"title":"Summer Exploration Arc #3","content":"## recap\nThis is the second progress update (third post overall) in the series I started on what I want to accomplish this summer. Read my last post [here](/2022-sea2).\n\nLooking at my general goals from last time: I haven't made much progress with Linux nor learned anything cybersecurity related. I did mess around with installing Ubuntu using UTM but I ended up putting it on the backburner. For the most part, I've been working through CS 220.\n\n## progress\n### self-studying\nThis past week I finished [CS 220](/notes/cs220)! Learning Python this way has honestly been a joy -- the content at the beginning of the course came naturally since I had some coding experience, and the later topics (web scraping, databases) were fun to mess around with. I think I never had a chance to explore while learning Java because I was more focused on learning *how* to code, like learning syntax rules or what functions were, but now I can actually apply my knowledge. I want to get some more Python experience under my belt first, but my ultimate goal is to give Caltech's [Learning From Data](https://work.caltech.edu/telecourse) another shot.\n\nI was recommended UC Berkeley's [CS 61A](https://inst.eecs.berkeley.edu/~cs61a/fa21/) by a friend, which I've picked up this week. There are three classes in the sequence: 61A, 61B, and 61C -- 61B focuses on Java, which was something that I really wanted to review this summer. This is mostly because I want to compete in some AI programming games, like [Battlecode](https://battlecode.org) or the [Lux AI Challenge](https://lux-ai.org), and I want to brush up on Java before the competitions start.\n\nFinally, I started a discrete math course because I need it for a prerequisite for my actual college classes, and I heard the one at UW-Madison is a disaster. \n\n### reading\nI finished *Normal People* by Sally Rooney. The ending was equal parts dissatisfying, ambiguous, and fitting.\n\n### SoME2\nThe deadline for SoME2 is August 15th, which is in a month. I think I'm going to make something about [Dijkstra's algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm), which is my favorite algorithm (that I know of). As far as animation and visuals go, I'm only familar with frame-by-frame hand-drawn animation -- I'm going to play around with FlipaClip this week and see how that works out.\n\n### misc\n- Current reads: *Homegoing* by Yaa Gyasi, *At Night All Blood Is Black* by David Diop\n\n## plan\nI'm focusing on balancing my two courses with my work schedule this week. I also want to finish another book and fiddle with my websites some more. Side goals: ICSI certification, break out the tablet and animate a little, and back up my favorite JCS crime videos somewhere.","lastmodified":"2022-10-14T05:23:27.468421016Z","tags":null},"/academics":{"title":"Classes","content":"\n## fall 2022\n- CS 475: Introduction to Combinatorics\n- CS 252: Introduction to Computer Engineering\n- ECE 537: Communication Networks\n- PHYSICS 201: General Physics\n- MSE 299: Independent Study (ML4ER)\n\n## summer 2022 (self-studied)\n- CS 220: Data Programming I\n- CS 61A: Structure and Interpretation of Computer Programs `almost finished!`\n- 6.042J: Mathematics for Computer Science `barely started`","lastmodified":"2022-10-14T05:23:27.468421016Z","tags":null},"/coding-shortcuts":{"title":"coding shortcuts","content":"\n## Python\n\n- find the max and min of a Series\n```python\ns = Series\n\ns.idxmin() # index of the min value\ns.idxmax() # index of the max value\ns.min() # min value\ns.max() # max value\n```\n\n- iloc, index, and name on a Series\n```python\n###\nArgentina    690.784168\nName: Chile, dtype: object\n###\n\ndf.iloc[0]  # returns 690.784168 -- \"integer location 0\"\ndf.index[0] # returns Argentina -- index(key) at location 0\ndf.name     # returns Chile\n```\n\n- iterating through two lists using `zip`\n```python\nfor (a, b) in zip(list_a, list_b)\n```\n\n- copying a tree and making changes at every leaf\n```python\nif is_leaf(t):\n        # return new leaf \n    else:\n        new_branches = []\n        for branch in branches(t):\n            new_branches.append(\u003crecursive call\u003e)\n        return tree(label(t), new_branches)\n```","lastmodified":"2022-10-14T05:23:27.468421016Z","tags":null},"/notes/6-042j":{"title":"6.042J","content":"\n# proofs\n\n## introduction to proofs\n\n- a **proposition** is a statement that is either true or false\n- the $::=$ means “equal by definition” and usually just $=$ is used\n- you can’t check a claim about an infinite set by checking a finite set of elements\n- symbols\n    - $\\forall$ for all\n    - $\\mathbb{N}$ nonnegative integers\n    - $\\in$ is in, is a member of, belongs to\n    - $\\mathbb{Z}^+$ positive integers\n\n**Proposition.** $313(x^3+y^3)=z^3$ has no solution when $x$, $y$, $z \\in\\mathbb{Z}^+$.\n\nThis latter part can be read as “when $x$, $y$, $z$ are in the set of all positive integers” or simpler, there is no solution when $x$, $y$, $z$ are all positive. This proposition is false (but the counterexample has more than 1000 digits.)\n\n- a **predicate** is a proposition whose truth depends on variables and is denoted by [a letter with a function-like notation], ex: “$n$ is a perfect square” depends on the value of the variable $n$\n    - $P(n)::=$ “$n$ is the perfect square”, where we can say $P(4)$ is true and $P(5)$ is false, then $P(n)$ is either true or false.\n- **axioms** are propositions that are simply accepted as true\n- a **proof** is a sequence of logical deductions using axioms and other proved statements\n- other terms for propositions\n    - **theorems** are *important* true propositions\n    - **lemmas** are preliminary propositions useful for proving later propositions\n    - **corollaries** are propositions that [follow in a few logical steps from a theorem] — *correlating* to a theorem\n- logical deductions are used to prove new propositions using previously proved propositions\n\n*modus ponens*: a proof of $P$ combined with a proof of $P\\text{ implies }Q$ is equivalent to a proof of $Q$\n\n**Rule.**\n\n$$\n\\frac{P,P\\text{ implies }Q}{Q}\n$$\n\n- statements above the line are proved (called *antecedents*), and statements below the line are called *conclusions*\n- propositions in the form of “if $P$, then $Q$” are called **implications**, and will often be rephrased to $P\\text{ implies }Q$\n    1. write “Assume $P$.”\n    2. show that $Q$ logically follows\n\n**Theorem.** $\\text{If }0\\le x\\le2\\text{, then }-x^3+4x+1\\gt0.$\n\n*Proof.*\n\n$$\n-x^3+4x=x(2-x)(2+x)\n$$\n$$\nx(2-x)(2+x)+1\\gt 0\n$$\n$$\n-x^3+4x+1\\gt 0\n\\tag*{$\\blacksquare$}\n$$\n\n- proofs begin with the word “*Proof*” and end with “QED” or $\\blacksquare$\n- a **contrapositive** is when $P\\text{ implies }Q$ is logically equivalent to $\\text{not(}Q\\text{) implies not(}P)$\n    1. write “We prove the contrapositive:”\n    2. write “Assume $\\text{not }Q$” and show that $\\text{not } P$ logically follows\n- a theorem can assert that two statements are logically equivalent, that one holds if and only if the other holds — the shortened phrase being $\\text{iff}$\n    - saying that $P\\text{ iff }Q$ is equivalent to saying $P\\text{ implies }Q$ and $Q\\text{ implies }P$\n        1. write “We prove $P$ implies $Q$ and vice-versa.”\n        2. show that $P$ implies $Q$ and show that $Q$ implies $P$\n    - $\\text{iff}$s can come in chains\n        1. write “We construct a chain of if-and-only-if implications.”\n        2. prove that $P$ is equivalent to a second statement which is equivalent to a third statement and a fourth statement and so forth until $Q$ is reached\n\n---","lastmodified":"2022-10-14T05:23:27.484421268Z","tags":null},"/notes/cs220":{"title":"CS 220","content":"Self-paced course taken summer '22, linked [here](https://www.msyamkumar.com/cs220/s20/syllabus.html). Introductory data science programming using Python -- teaches Python basics, programming fundamentals, and data science modules in Python. Texts used include Allen B. Downey's *Think Python, 2nd Edition* and Al Sweigart's *Automate the Boring Stuff*. Completed homework linked [here](https://github.com/heyitssqueak/classes/tree/master/cs220).\n\n# control flow\n\n## introduction\n- inputs: keyboard, mouse\n- outputs: monitor, speaker\n- devices attach to the computer via “ports” (USB)\n- motherboard: main circuit and connects to other components with sockets and slots\n- CPU, central processing unit\n    - runs code (receives input, sends output)\n    - runs on a clock, measured in Hz (ex. GHz is billions of ticks per second)\n    - high speed CPU → hotter\n    - computers have multiple CPUs\n- RAM, random access memory\n    - short term data storage\n        - CPU sends to and from RAM\n    - “volatile” - lose data when computer is powered off\n    - one byte = one letter\n- storage drives\n    - HDD, hard disk drive\n        - inexpensive, moving parts, slow\n    - SSD, solid state drive\n        - expensive, no moving parts, fast\n    - stores data after computer shut down\n- network: an extension or built-in card to the motherboard\n    - NIC, network interface controller\n        - provides communication to other machines + internet\n    - wired = ethernet, wireless = wifi\n    - server: computer waits for incoming requests which it responds to\n    - client: program that sends requests to a server\n- jupyter notebook runs and displays results of py code without needing to run it yourself\n\n---\n\n## the terminal\n\n- you can connect to terminals located anywhere, such as connecting to a remote computer OR connecting to a personal computer\n- shell helps navigate to program and run\n- helpful shell commands    \n    - `pwd` get working directory → current location\n    - `man` opens manual pages for command\n    - `\u003ctab\u003e` autocomplete\n    - `\u003cctrl-C\u003e` kill / exit\n    - `\u003cup arrow\u003e` last used command\n    - `\u003cctrl-R\u003e` search used commands\n    - `cd` open directory\n        - `cd ..` go up a directory\n        - `cd /` go to top directory\n    - `ls` lists contents of current directory\n    - `mkdir` makes new directory\n    - `echo` repeat or copy\n    - `cat` display contents of file\n    - `mv [original] [destination]` move files\n    - `cp [original] [destination]` copy files        \n- pathname: the location of your file (windows: includes drive letter, filename, extension…)\n    - absolute: always possible (complete path name to file)\n    - relative: with respect to current location\n    - working directory: current location\n    - `..` navigates up a directory\n    - `.` navigates into a directory\n- arguments are inputs that come after the call of the program name\n- use `\u003e` to redirect output to a new file\n- use `\u003e\u003e` to add output to a file\n\n---\n\n## programming\n\n- interpreter: a program that translates human-legible code into machine-legible code\n- editor: a program where you can write code\n- jupyter notebook mixes code with other things like images, tables, documentation, etc\n- ways to run python\n    - `python` interactive, denoted by `\u003e\u003e\u003e`\n    - `python [program name]` script\n    - `jupyter notebook` notebook\n- python uses order of operations to simplify equations (parentheses, exponents, m/d, a/s)\n    - negative and positive signs take precedence over m/d\n    - logic operators come after comparison operators which come after math operators\n![operator-diagram](/images/cs220/operator-precedence.png)\n- boolean operators\n    - AND: true when both conditions are true (t/t), false otherwise (t/f, f/t, f/f)\n    - OR: true when one condition is true (t/t, t/f, f/t), false otherwise (f/f)\n    - NOT: true when the condition is false\n        - evaluate: NOT(is it saturday?)\n            - if (is it saturday?) is true, then the expression is false, i.e., it IS saturday\n            - if (is it saturday?) is false, then the expression is true, i.e., it is NOT saturday\n\n### downey ch1: the way of the program\n\n- python uses symbols as *bitwise* operators and words as logic operators\n    - `and` `or` are logic operators\n    - `\u0026` `|` are bitwise operators\n        - convert arguments into binary before comparisons\n- common types: int, float, string, boolean\n- parsing is understanding structure and meaning in a language\n    - formal language: specifically designed languages (like mathematical or molecular notation); means exactly what it says, unambiguous, less redundant/more concise\n    - natural language: naturally-evolved language (like English); has idioms/metaphor, needs redundancy to make up for ambiguity\n\n---\n\n## variables and expressions\n\n- expressions are a mix of operators (logic, mathematical) and operands (values)\n    - an operand *could* be a variable which means it won’t be a fixed value\n    - `//` is the floor division operator: `x // y` is “how many times does `y` go into `x`?\n- assignments compute an expression and put the result in a variable — assignment operator is `=`\n    - ex: `total = x+y` where `total` is the resultant variable; `x` and `y` are operands (and also variables); `x+y` is the expression\n- types of errors\n    - syntax error: the written code is wrong, Python won’t run, ex: `5 = x`, we can’t assign `x` to the number `5`\n    - runtime errors: something that crashes when we run the code, ex: `x = 5 / 0`, can’t divide by zero and will result in a `ZeroDivisionError`\n    - semantic (logic) error: the code runs but you don’t get the result you want\n- python variable naming conventions\n    - don’t use keywords\n        |     |     |     |     |     |     |     | \n        | --- | --- | --- | --- | --- | --- | --- |\n        | False | assert | del | for | in | or | while |\n        | None | break | elif | from | is | pass | with |\n        | True | class | else | global | lambda | raise | yield |\n        | and | continue | except | if | nonlocal | return |  |\n        | as | def | finally | import | not | try |  |\n    - don’t name your variable after a type, like `int` or `str`\n    - only use letters (upper + lower), numbers, underscores\n        - don’t start the variable name with a number\n    \n    | examples | nonexamples |\n    | --- | --- |\n    | CS220 | 220class |\n    | cs_220 | x! |\n    | _cs220 | pi3.14 |\n\n### downey ch2: variables, expressions and statements\n\n- python conventionally uses lowercase and underscores for variable names\n    - illegal names will cause syntax errors\n- python code can be saved into files called *scripts* which end with `.py`\n- `print()` needs to be used in script mode if you want to display outputs\n- PEMDAS is helpful for remembering the order of operation for expressions\n    - **P**arentheses, **E**xponents, **M**ultiplication and **D**ivision, **A**ddition and **S**ubtraction\n- can’t perform mathematical operations on strings but we *can* add strings together (called string concatenation)\n    ```python\n    first = 'throat'\n    second = 'warbler'\n    print(first + second)\n    \u003e throatwarbler\n    ```\n- strings can also be multiplied, ex: `'Spam'*3` is `'SpamSpamSpam'`\n- comments are lines that the computer will ignore — used to make notes between lines of code for humans to read\n    ```python\n    # compute percentage of an hour\n    percentage = (minute * 100) / 60\n    ```\n    - everything on the line with the `#` symbol is ignored\n    - usually used to denote things that aren’t obvious to the reader — meanings of variables, functions\n- syntax errors appear *before* the program is run; runtime errors appear *after* the program has run; semantic errors don’t appear at all\n\n---\n\n## using functions\n\n- functions are “mini-programs” or small steps that can build a big program\n- refactoring is when the code is reorganized\n- **parameters** are variables that receive a function’s input\n- **arguments** are values that are sent to a function\n    - default arguments are values that are sent to the function *if* no custom value is provided\n- **return values** are outputs from the function\n![params-args](/images/cs220/params-and-args.png)\n- calling a function in python: `[fnc name]([arguments])` ex: `print(\"hello\")` where `print` is the function name, followed by parentheses, and `\"hello\"` is the argument\n\n### downey ch3: functions\n\n- **function** - a named sequence that performs a computation\n- python has *modules* which are prewritten code that you can use in your program by importing\n    - ex: functions from the math module can be used after importing it with `import math`, including `math.sin()`, `math.log10(), etc`\n- functions can be called using *dot notation* which is the format `[module name].[function name]`\n- variables are always on the left side of an assignment operator\n\n---\n\n## creating functions\n\n- math to python example\n    $f(x)=x^2$\n    `def f(x):\n        return x ** 2`\n    - both functions are called `f` and take a parameter, `x`, and return the value of `x` squared\n- indentation is important in python!\n    - following the colon after the first line of a function, all following lines are indented 4 spaces\n- filling parameters\n    - positional arguments — arguments assigned by position\n        ```python\n        def foo(x, y = -1):\n            x = [] # this would be 99, because 99 is the first arg\n    \t    y = [] # this would be 100\n\n        foo(99, 100)\n        ```\n    - keyword arguments — arguments assigned to variable names\n        ```python\n        def foo(x, y = -1):\n            x = [] # this would be 100 because we said x=100 below\n            y = [] # this would be 99\n        \n        foo(y=99, x=100)\n        ```\n    - default arguments — inserted arguments if nothing is provided\n        ```python\n        def foo(x, y = -1):\n            x = [] # this would be 99 \n            y = [] # this would be -1 because we specified it above\n        \n        foo(99)\n        ```\n- `return` will provide code to the program that can be used later, while `print()` will output the code to a terminal\n\n### downey ch3 (cont.): functions\n\n- custom functions can be added by using the keyword `def`\n    - the **header** of the function is the first line, while the **body** **(indented 4 spaces) is the rest of the function\n- if the parentheses after the function name are empty, that means the function doesn’t take any arguments\n    ```python\n    def foo():\n        print(36)\n    \n    foo()\n    \u003e 36\n    ```\n- functions have to be created before they can be called → function definitions are always at the top of a program\n    - execution begins at the top of the program and moves down\n- *fruitful functions* return values; *void functions* don’t return anything\n    - usually want to perform an action with the output of a fruitful function\n\n### reading: creating fruitful functions\n\n- to send a value to a variable instead of printing it to a screen, we can use the `return` keyword → is called a fruitful function\n    - result is stored in a variable and can be used again\n    ```python\n    # using print\n    def get_name(first, last):\n        print(first + \" \" + last)\n    \n    name = get_name(\"Jane\", \"Doe\")\n    \u003e \"Jane Doe\"\n    \n    print(name)\n    \u003e None # nothing is assigned to 'name' so it has the None type\n    ```  \n    $\\phantom{-}$\n    ```python\n    # using return\n    def get_name(first, last):\n        return(first + \" \" + last)\n    \n    name = get_name(\"Jane\", \"Doe\") # nothing prints because there is no print statement\n    \n    print(name)\n    \u003e \"Jane Doe\" # the name is returned through the function\n    ```\n- once a `return` statement is reached, the function ends\n    ```python\n    # using print()\n    def countdown_print():\n        print(3)\n        print(2)\n        print(1)\n    \n    countdown_print()\n    \u003e 3\n    \u003e 2\n    \u003e 1\n    ```\n    $\\phantom{-}$\n    ```python\n    # using return\n    def countdown_return():\n        return 3\n        return 2\n        return 1\n    \n    countdown_return()\n    \u003e 3\n    ```\n- `__builtins__` is a special module that is already imported\n- `dir()` lists all functions that are part of a module\n- `.__doc__` returns the documentation of a function\n    ```python\n    import math\n\n    print(math.log.__doc__) # [module name].[function name].__doc__\n    \u003e log(x, [base=math.e])\n    \u003e Return the logarithm of x to the given value\n    ```\n\n---\n\n## function scope\n\n- variable names can be organized in *frames*\n- **frames** are created when a function is called — parameters and variables exist in the frame (also called scope?)\n    ```python\n    def print_twice(s): # function frame\n        print(s)\n        print(s)\n    \n    def cat_twice(p1, p2): # different function frame\n        cat = p1 + p2\n        print_twice(cat)\n    \n    line1 = \"bing bong\" # lies in the global frame\n    line2 = \"bong bing\" # lies in the global frame\n    cat_twice(line1, line2)\n    ```\n    - the module can access two variables: `line1` and `line2`\n    - `cat_twice()` accesses three variables: `p1` (which is `line1` passed through the function), `p2` (which is `line2` passed through the function), and `cat`\n    - `print_twice()` only accesses one variable: `s` which is `cat` passed through\n- local variables\n    - functions don’t execute unless they’re called\n        ```python\n        def set_x():\n            x = 100\n        \n        print(x)\n        # doesn't print anything because set_x() wasn't called\n        ```\n    - variables created in a function die after the function returns\n        ```python\n        def set_x():\n            x = 100\n        \n        set_x()\n        print(x)\n        # doesn't print because x doesn't exist after the end of the function\n        ```\n    - variables are reset every time a function is called\n    - variables aren’t shared across functions\n        ```python\n        def display():\n            print(x)\n        \n        def main():\n            x = 100\n            display()\n        \n        main()\n        ```\n        - even though `x` is set to be `100` in the `main()` function, the `display()` function can’t see the `x` value and it doesn’t print anything\n- global variables can be used inside functions\n    - python assumes any variables assigned within functions are *local variables*\n        ```python\n        msg = \"hello\"\n        \n        def greeting():\n            msg = \"welcome!\" # local variable, only present within the function\n            print(\"greeting: \" + msg)\n        \n        print(\"before: \" + msg) \n        greeting()\n        print(\"after: \" + msg)\n        \n        \u003e before: hello\n        \u003e greeting: welcome!\n        \u003e after: hello\n        ```\n- use `global [var name]` to declare when to create a global variable\n    ```python\n    msg = \"hello\"\n    \n    def greeting():\n        global msgd\n        msg = \"welcome!\" # local variable, only present within the function\n        print(\"greeting: \" + msg)\n    \n    print(\"before: \" + msg) \n    greeting()\n    print(\"after: \" + msg)\n    \n    \u003e before: hello\n    \u003e greeting: welcome!\n    \u003e after: welcome!\n    ```\n- python arguments are “passed by value” meaning any change to an argument that happens inside a function does *not* apply to that variable outside of the function\n- the argument and parameter can have the same (or different) name\n\n### downey ch3 (cont.): functions\n\n- inside a function, arguments are assigned to variables called *parameters*\n- variables created inside functions exist only in that function\n- a **traceback** is a list of functions that details what file, line, and functions caused an error\n- usefulness of functions\n    - repetitive code can be named and grouped, which makes debugging easier\n    - reusuable\n- Linux started out as a program that would switch between printing `AAAA` and `BBBB`\n\n---\n\n## conditionals\n- statements are always executed in order, with three exceptions: functions, conditionals, and loops\n- indented lines = “inside” functions\n- questions are often phrased as boolean expressions, while actions are written as statements\n- control flow diagrams are flowcharts for code — visual representation of how the code should run\n    ![conditionals](/images/cs220/conditionals.png)\n- a boolean expression uses the `if` keyword and sometimes uses `else` if there are multiple solutions\n    ```python\n    if [boolean expression == True]:\n        # execute code\n    else: # implying that boolean expression == False\n        # execute different code\n    ```\n- *blocks* of code are defined by indentations (which come with colons)\n\n### downey ch4: case study: interface design\n\n- the `turtle` module in python allows you to create images with turtle graphics\n    - basically, it’s a little “turtle” that you can control using commands (move forward, turn left) to draw stuff\n- `for` loops can be used to repeat pieces of code\n    ```python\n    for i in range(4):\n        print(i + \"hello!\")\n    \n    \u003e 0 hello!\n    \u003e 1 hello!\n    \u003e 2 hello!\n    \u003e 3 hello!\n    ```\n    - the `i` is a counter variable — starting at 0, it will increase by 1 every loop\n    - `4` is the number of times the loop will repeat\n- **encapsulation** is when you wrap up code in a function\n    - this gives the code a name, which serves as documentation (noting what its purpose is)\n- **generalization** is adding parameters to a function to make it more “customizable”, ex: creating a function that draws a square of *any* size instead of just 1 size\n- the **interface** of a function is a summary of how the function is used, including parameters, purpose, return values\n    - a good interface achieves its purpose without needing to provide unnecessary information\n- **refactoring** is the process of rearranging a program to improve interfaces — the goal is to make the code more readable and still be useful\n- **docstrings** are strings at the top of a function that explains the interface (basically describes the purpose of the function)\n    - doc = documentation\n    - also called headers or javadoc comments in Java\n    - all docstrings are *triple-quoted*\n    ```python\n    def polyline(t, n, length, angle):\n        \"\"\"Draws n line segments with the given length and angle (in degrees) between them. t is a turtle.\"\"\"\n        for i in rage(n):\n            t.fd(length)\n            t.lt(angle)\n    ```\n- **preconditions** are things that are required to be true *before* the start of a function, ex: the `angle` parameter has to be a positive value\n- **postconditions** are conditions at the end of the function\n    - if the postconditions are wrong but the preconditions are satisfied, then the bug is within the function\n\n### downey ch5: conditionals ~~and recursion~~\n\n- the **floor division operator** (`//`) divides two numbers and returns the integer (rounds down), ex: `5 // 3 = 1`\n- the **modulus operator** (`%`) divides two numbers and returns the remainder, ex: `5 % 3 = 2`\n- a **boolean expression** will evaluate to either `True` or `False` and uses the `==` operator\n    - `!=` not equal to\n    - `\u003e` greater than\n    - `\u003c` less than\n    - `\u003e=` greater than or equal to\n    - `\u003c=` less than or equal to\n- **logical operators**: `and` `or` `not`\n- `if` statements are *conditional* statements, which check conditions\n    ```python\n    if x \u003e 0: \n        print(\"x is positive\")\n    ```\n    - if there is more than one possibility of the conditional statement, `else` clauses can be added\n        ```python\n        if x \u003e 0:\n            print(\"x is positive\")\n        else: \n            print(\"x is negative\")\n        ```\n    - if there are more than *two* possibilities, use `elif` to define other conditions\n        ```python\n        if x \u003e 0: \n            print(\"x is positive\")\n        elif x \u003c 0:\n            print(\"x is negative\")\n        else: \n            print(\"x is 0\")\n        ```\n- conditionals can also be nested inside each other — the next example is a re-write of the previous one\n    ```python\n    if x \u003e 0:\n        print(\"x is positive\")\n    else:\n        if x \u003c 0:\n            print(\"x is negative\")\n        else:\n            print(\"x is 0\")\n    ```\n\n### downey ch6: fruitful functions\n\n- return values are usually assigned to variables or used in an expression\n    - if conditional statements are used, there can be multiple return statements — it’s good practice to make sure the program can return a value no matter which path it takes\n- code that appears *after* a return statement is called **dead code** because it will never be executed\n- **incremental development** is the process of adding and debugging code in small chunks as to avoid long/complicated debugging sessions\n    - comments or tester pieces of code are called **scaffolding** which can be helpful for debugging, but aren’t part of the final product\n    - start with a working program and make small changes\n    - display intermediate values\n    - remove scaffolding to make code easier to read\n- one function can be called from within another\n- functions can return booleans\n    - common for the function name to be a yes/no question, like `is_even()`, `is_raining()`, or `is_divisible()`\n\n---\n\n## iteration\n\n- control flow diagram for a `while` loop\n    ![while-loop](images/cs220/while-loop.png)\n- basic code for a `while` loop\n    ```python\n    while [condition]:\n        # execute code\n    ```\n- to repeat a loop `n` times, either use `i = 1` and `i \u003c= n` OR `i = 0` and `i \u003c n` because python starts counting from 0 and not 1\n- `break` immediately exits a loop, just like how `return` will immediately exit a function\n- the keyword `continue` will stop the *current iteration* and checks the condition to begin the next iteration\n- loops can be nested\n\n### ch7: iteration\n\n- **reassignment** is when an existing variable is updated to have a new value\n    - equality in python (and other languages) isn’t achieved through the `=` operator, ex: saying `a = 3` and `a = b` does not mean `b = 3`\n- an **update** is a specific type of reassignment where the new value is dependent on the old value\n    - **increments** are when a variable is updated by adding 1, **decrements** are when a variable is updated by subtracting 1\n- a variable has to be initialized (it has to exist) before it can be updated\n- repetition can be called **iteration**\n- `while` loops will execute as long as the condition remains true after each iteration\n    ```python\n    while n \u003e 0: # while n is greater than 0, display and decrement n\n        print(n)\n        n = n - 1\n    print(\"Blastoff!\")\n    ```\n    - an **infinite loop** is a loop that repeats forever, and occurs when there is no way for the condition to evaluate as false\n- `break` statements can be used to exit loops in the middle rather than at the beginning or end\n- an **algorithm** is a mechanical process for solving problems\n\n### sweigart ch2: flow control\n\ntodo\n\n---\n\n## strings\n\n- python can compare strings just like it can compare numbers with three edge cases: upper vs. lowercase, digits, prefixes\n    - uppercase always comes before lowercase, ex: `\"Z\"` \u003c `\"a\"`\n    - numbers in string form aren’t actual numbers, they are still considered strings and digits are compared to each place, ex: `\"100\"` \u003c `\"15\"`\n    - prefixes always come first, ex: `\"bat\"` \u003c `\"batman\"`\n- the `isDigit()` function returns if all the characters within a string are digits\n- a **method** is a special function that’s called on a variable or value, such as `isDigit()` or `upper()`, while functions pass variables or values as parameters\n    ```python\n    msg = \"hello\"\n    \n    msg.isDigit() # method\n    msg.upper() # method\n    \n    len(msg) # function\n    ```\n- **sequences** are collections of ordered values, such as strings, lists, or tuples\n![array](images/cs220/string-array.png)\n- **indexing** a string is when you access a value of the string, while **slicing** is taking a chunk of a string\n    - each character in the string has its own *index* value which is the number to call to retrieve that character\n![indexing](images/cs220/string-indexing.png)\n- both `while` loops and `for` loops can be used to iterate through string\n    ```python\n    msg = \"hello\"\n    \n    # while loop\n    i = 0\n    while i \u003c len(msg):\n        letter = msg[i]\n        print(letter)\n        i += 1\n    \n    # for loop\n    for letter in msg:\n        print(letter)\n    ```\n- `for` loops can also have a *range* which is a way of telling the computer how many times the loop should be executed\n    ```python\n    for i in range(5): # will iterate 0 to 4\n        print(i * 3)\n    \n    \u003e 0\n    \u003e 3\n    \u003e 6\n    \u003e 9\n    \u003e 12\n    ```\n\n### downey ch8: strings\n\n- a string is a *sequence*\n- the **index** is a value that corresponds to a character within a sequence, ex: my sequence is `\"banana\"` and the value at index `1` is `\"a\"` (because python starts counting at 0)\n    - the index has to be an integer value\n- `len()` is a builtin function that returns the number of characters in a string\n- negative indices can be used to count backwards from a string, where the `-1` index returns the last character, `-2` index returns the second-to-last, etc\n- `for` loops can be used to traverse through strings, also called for-each loops\n    ```python\n    fruit = \"banana\"\n    \n    for letter in fruit: # the loop iterates from 0 to 5\n        print(letter)\n    \n    \u003e b # 0th index\n    \u003e a # 1st index\n    \u003e n # 2nd\n    \u003e a # 3\n    \u003e n # 4\n    \u003e a # 5\n    ```\n- string segments are called **slices** which can be obtained using the `[n:m]` operator where the operator includes the `n` letter but not the `m` value, ex: `fruit[1:4]` would return `\"ana\"`\n    - if the `n` is omitted, the slice starts at the beginning and ends at the `m` value, ex: `fruit[:4]` would return `\"bana\"`\n    - if the `m` is omitted, the slice starts at the `n` value and ends at the end of the string, ex `fruit[4:]` would return `\"na\"`\n    - a third argument can be used called *step size* which is the number of spaces between characters, ex: `fruit[0:5:2]` would return `\"bnn\"`\n        - `[start : end : step size]`\n- strings are **immutable** which means an existing string can’t be changed\n- a **counter** is a variable in a loop that starts at 0 and increments each time a condition is met — sometimes the value of the counter is returned at the end of the loop\n- an **invocation** is when a *method* is called on an object, such as the `upper()` method, ex: `fruit.upper()` produces `\"BANANA\"`\n- the `find()` method can return the index where a substring (or character) starts, but it can also take an argument for which index in the string it starts looking at, ex: `fruit.find(\"na\")` produces `2`\n- the `in` operator for strings returns a boolean value if the substring is present in the string, ex: `\"a\" in \"banana\"` returns `True`\n- relational operators (`==`, `\u003c`, `\u003e`) work on strings and are used to put words in alphabetical order, but *all uppercase letters come before lowercase letters*\n\n### downey ch9: case study: word play\n\n- there is a built in function to read files — `open( [filepath] )`\n- to read lines of the file, use `readline()`, which will read the next line of the file until it gets to the end of the file\n    - sometimes the lines will end with whitespace characters such as `\\r\\n` which we can get rid of by using the `strip()` function after the `readline()` function\n- the process of reading a file can be made easier by using a `for` loop\n- when testing programs, keep in mind **special cases** which are non-obvious cases that can produce errors, ex: what if a function is called on an empty string?\n\n\u003e Program testing can be used to show the presence of bugs, but never to show their absence! —Edsger W. Dijkstra\n\n---\n\n# state\n\n## lists\n\n- a string is a sequence of characters — a list is a sequence of anything!\n    - we can index, slice, and put lists in `for` loops and also use the `len()` function, concatenate with the `+` operator, use the `in` operator to find elements, and multiply by integers\n```python\n# using len()\nmsg = \"321go\"\nlen(msg)\n\u003e 5\n\n# concatenation\nmsg = \"321go\"\nmsg + \"!!!\"\n\u003e \"321go!!!\"\n\n# using in\nmsg = \"321go\"\n\"g\" in msg\n\u003e True\n\n# multiply by int\nmsg = \"321go\"\nmsg * 3\n\u003e \"321go321go321go\"\n```\n$\\phantom{-}$\n```python\n# using len()\nitems = [99,11,77,55]\nlen(items)\n\u003e 4\n\n# concatenation\nitems = [99,11,77,55]\nitems + [1,2,3]\n\u003e [99,11,77,55,1,2,3]\n\n# using in\nitems = [99,11,77,55]\n11 in items\n\u003e True\n\n# multiply by int\nitems = [99,11,77,55]\nitems * 2\n[99,11,77,55,99,11,77,55]\n```\n![string-list](images/cs220/string-list-comparison.png)\n\n### downey ch10: lists\n\n- a **list** is a *sequence*\n    - elements of a list, called **items**, can be of any type (unlike strings, where they have to be characters) — they can even be different types than other elements within the same list\n- to create a new list, use square brackets to enclose the elements, ex: `cheeses = [\"Cheddar\", \"Gouda\", \"Mozzarella\", \"Swiss\"]`\n- lists within lists are called *nested* lists\n- empty lists don’t contain elements and can be created using empty brackets, ex: `empty = []`\n- the bracket operator `[]` can be used to access elements of a list (just like how brackets are used to access characters in a string), ex: `cheeses[1] = \"Gouda\"`\n    - lists are **mutable** which means that elements in the list can be changed\n- the `in` operator can be used on lists to find elements\n- when iterating through lists, the `in` operator will NOT update the elements in the list — to update the elements, you have to use `range()` and `len()`\n    ```python\n    cheeses = [\"Cheddar\", \"Gouda\", \"Mozzarella\", \"Swiss\"]\n    \n    for cheese in cheeses: # will NOT change the cheeses list\n        cheese = \"eaten\"\n    \n    for i in range(len(cheese)): # WILL change the cheeses list\n        cheese[i] = \"eaten\"\n    ```\n- the `+` operator will join lists while the `*` operator will repeat a list a given number of times\n- list slicing works the same way as strings — using the `[start : end : step size]` operator, sections of lists can be isolated\n- since lists are mutable, a good programming practice is to make a copy of the list before modifying it\n- list methods\n    - `append()` adds a new item to the end of the list\n    - `extend()` takes a list as an argument and adds the entire list to the main list\n    - `sort()` arranges the list elements from low to high\n    - `pop()` removes and returns the final element in a list, or it can remove and return the item at a specified index\n        - the `del` keyword accomplishes the same thing but without a return value\n    - `remove()` removes the item with the specified *value*\n        ```python\n        cheeses = [\"Cheddar\", \"Gouda\", \"Mozzarella\", \"Swiss\"]\n        \n        # the two statements below achieve the same purpose\n        cheeses.pop(1) # used if you know the index\n        cheeses.remove(\"Gouda\") # used if you know the value\n        ```\n- special types of operators\n    - **map** alter every element in a sequence\n    - **reduce** simplifies a sequence of elements into a single value\n    - **filter** removes some elements and returns others, usually according to a user-given rule\n- the `list()` function breaks a string into a list of characters, ex: `list(”hello”)` returns `['h', 'e', 'l', 'l', 'o']`\n- the `split()` function breaks a string into a list of words\n    - it can take a **delimiter** as an argument which is a specified boundary to split words\n        ```python\n        delimiter = \"-\"\n        str = \"spam-spam-spam\"\n        \n        str.split(delimiter) # produces [\"spam\", \"spam\", \"spam\"]\n        ```\n- the `join()` function joins a list into a string\n- two lists can be *equivalent*, meaning they have the same elements, but not *identical*, because they are referring to two different objects\n- identical → equivalent, but equivalent does not mean identical\n![equivalent](images/cs220/equivalent.png)\n- a variable assigned to an object is called a **reference**, and when an object has more than one reference, that means it is **aliased**\n    - if the aliased object is mutable, then any change will affect all aliases of the object\n- some operations (`append()` , `split()`, `[::]`) modify lists, while other operations (`+`, `*`) create new lists\n\n---\n\n## CSV tables\n\n- CSVs organize cells of data into rows and columns\n    - only holds strings and all text is plaintext\n- **delimiters** are characters that act as separators between objects — for CSVs, the delimiter is a comma\n- when a CSV is opened in python, its result is a list of lists (or like a 2D array)\n\n### sweigart ch16: working with CSV files ~~and JSON data~~\n\n- CSV, comma-separated values, are simplified spreadsheets stored as plaintext — supported by many types of programs and is very simple, exactly as advertised\n- each row in a CSV file represents a row in a spreadsheet, and each comma represents the next column\n- the `csv` module has a `reader` object which helps the user read the CSV file\n    ```python\n    import csv\n    exampleFile = open(\"example.csv\") # open the file\n    exampleReader = csv.reader(exampleFile) # \"reads\" the file and returns a reader object\n    exampleData = list(exampleReader) # converting data into list\n    \n    exampleData[0][0] # data at row 0, col 0\n    exampleData[0][1] # data at row 0, col 1\n    ```\n    - for larger CSV files, use a `for` loop and load one row at a time\n        ```python\n        for row in exampleReader: # iterating through reader object\n            str(row)\n            # execute code\n        ```\n\n---\n\n## dictionaries\n\n- a **data structure** is a collection of data values, their relationships, and the operations that can be applied to the data\n- **maps** associate values with labels and use labels to lookup values\n    - *lists* are maps which associate indices with values\n- dictionaries map labels (keys, not indices) to values — keys must be immutable\n    ```python\n    nums_dict = {\"first\":900, \"second\":700, \"third\":800}\n    \n    nums_dict[\"third\"] # accessing 800\n    ```\n- reminder on parenthetical characters\n    - parentheses `()`: specifying order, calling functions\n    - brackets `[]`: creating lists, indexing, slicing, dictionary lookups\n    - braces `{}`: creating dictionaries, creating sets\n- use the `pop()` method to delete elements in the dictionary — by default, `pop()` accepts keys\n- to add elements, assign keys to values using brackets like `d[20] = \"twenty\"`\n- create an empty dictionary `d = {}` or `d = dict()`\n- the `in` operator only checks if keys are present in the dictionary, it does not check for values\n- keys and values can be extracted and turned into lists using `list(d.keys())` or `list(d.values())`\n- use `get()` to return values, `pop()` to delete values in a dictionary and specify a default value if the key doesn’t exist\n- **bucketing/binning**: dictionary of lists\n![bucketing](images/cs220/bucketing.png)\n- **table representation**: list of dictionaries\n- **probability tables/Markov chains**: dictionary of dictionaries\n![probability-dict](images/cs220/probability-dict.png)\n\n### downey ch11: dictionaries\n\n- dictionaries have **keys** and **values** which make up **items** — each key is mapped to a value\n- create a new dictionary using the `dict()` function or two curly brackets `{}`\n    - add elements to a dictionary by using square brackets and assigning a value, ex: `nums[\"1\"] = \"one\"` where `nums` is the dictionary, `\"1\"` is the key, and `\"one\"` is the value\n- dictionaries are not ordered — the only thing that matters is the key-value pairs stay the same\n- the `values()` method returns a collection of all the values\n- the `in` operator, `len()` function, and `sorted()` function all work on dictionaries\n- the `get()` method returns the corresponding value associated with a key — if there is no value then it returns a default value\n- a list can be a value in a dictionary, in other words, a list can be a value that is assigned to a key:value pair\n    - a list cannot be a key because the keys need to be hashable\n- a **singleton** is a list that contains a single element\n- a **hash** is a special function that takes values of any kind and returns and integer\n    - dictionaries use the integers (called hash values) to store key:value pairs\n    - hashes only work if the object is immutable (and lists aren’t immutable)\n- a **memo** is a dictionary that can be used to keep track of values that are already known\n    - when calculating the Fibonacci sequence, a memo can be used to store values that were already calculated\n- variables created outside functions are called **global variables** because they are located in the `__main__` frame\n- **flags**, boolean values for conditions, are usually global variables\n    - have to be declared within functions before they can be changed, ex: `global is_called` before using `is_called = !is_called`\n\n---\n\n## JSON\n\n- CSVs are good at storing list of lists, JSONs are good at storing dict of dicts\n\n### sweigart ch16: working with ~~CSV files and~~ JSON data\n\n- JSON, JavaScript Object Notation, stores information as JavaScript source code in plaintext files\n- application programming interface (API) is a way to bridge programs with their applications\n    - lets you scrape raw data from the website\n- the `json` module handles all the stuff between JSON data and python values using `json.loads()` and `json.dumps()` functions\n    - data can be read with the `loads()` function which will return the data as a dictionary\n    - data can be written with the `dumps()` function which can only take dictionary, list, int, float, string, Boolean, or `None` data types and will translate it into JSON data\n\n---\n\n## objects\n\n- using parentheses instead of brackets will create a tuple instead of a list\n    - like a list, `for` loops, indexing, slicing can be done\n- the `namedtuple` object can be imported and it will allow new types to be created\n    ```python\n    from collections import namedtuple\n    \n    Person = namedtuple(\"Person\", [\"fname\", \"lname\", \"age\"])\n    people = [\n        Person(\"Alice\", \"Anderson\", 30)\n        Person(\"Bob\", \"Baker\", 31)\n    ]\n    p = people[0]\n    print(\"Hello \" + p.fname + \" \" + p.lname)\n    \n    \u003e Hello Alice Anderson\n    ```\n- the mutable equivalent of a `namedtuple` is called a `recordclass`, ie: variables can be changed after they have been assigned\n- python uses separate references and objects because: 1) performance; 2) centralized updates\n- the `is` operator will return `True` when two references point to the same object, while the `==` operator only checks if the two objects are equivalent\n\n### downey ch10: lists\n\n- the `is` operator can tell you if two objects are equivalent and identical\n- identical implies equivalent, but equivalent does not imply identical\n\n### downey ch12: tuples\n\n- a tuple (too-ple) is an immutable list usually enclosed in parentheses — create an empty one using `tuple()`\n    - can also refer to a group of objects in general\n- the bracket operator (for indexing) and slice operator `[::]` work on tuples\n- for relational operators (`\u003c`, `\u003e`, `=`) work by comparing each element of the tuple until there is a difference, and subsequent elements are not considered\n    - `(0, 1, 2) \u003c (0, 3, 4)`\n    - `(0, 1, 2000000) \u003c (0, 3, 4)`\n- tuples can be assigned in a special way\n    ```python\n    a, b = b, a\n    # tuple of variables on the left\n    # tuple of expressions on the right\n    ```\n    - the number of variables on the left side has to be equal to the number of expressions on the right side\n        ```python\n        addr = \"monty@python.org\"\n        uname, domain = addr.split(\"@\")\n        ```\n- a parameter that begins with `*` will **gather** all arguments into a tuple\n    ```python\n    def printall(*args):\n        print(args)\n    \n    printall(1, 2.0, \"3\") # combines all arguments into tuple\n    ```\n- an argument that uses the `*` operator on a tuple will break the tuple (**scatter**) into multiple arguments (so the opposite of a *gather*)\n    ```python\n    t = (7, 3)\n    divmod(*t) # breaks t into 2 arguments\n    ```\n- the `zip()` function takes multiple sequences and returns a list of tuples where each tuple has an element from each sequence\n    - the zip object is an **iterator** which means that it’s an object that iterates (moves through) a sequence — usually has a `.next()` and no indices\n    ```python\n    s = \"abc\"\n    t = [0, 1, 2]\n    zip(s,t) # creates a zip object\n    \n    for pair in zip(s,t):\n        print(pair)\n    \n    \u003e (\"a\", 0)\n    \u003e (\"b\", 1)\n    \u003e (\"c\", 2)\n    ```\n    - if the sequences are different lengths, the zip object ends when the first sequence ends\n    - this is very useful for traversing through multiple sequences at the same time\n- the `enumerate()` function creates an enumerate object, or a sequence of pairs matching an index to an element in the argument\n    ```python\n    for index, element in enumerate(\"abc\"):\n        print(index, element)\n    \n    \u003e 0 a\n    \u003e 1 b\n    \u003e 2 c\n    ```\n- dictionaries have a method called `items()` that returns a sequence of tuples of key:value pairs\n- a list of tuples can be initialized into a new dictionary using `dict()`\n- tuples are commonly used as keys in dictionaries because lists can’t be used as dictionaries (tuples are immutable, lists are not)\n\n---\n\n## copying\n\n- slicing creates a new object\n- three levels of copying\n    - reference copy (0 levels): fastest but most dangerous, only creates a pointer to the object — any changes to either object will change both\n    - shallow copy (1 level): used to copy an object (ie, a list) so the original doesn’t get corrupted, but it only makes a new object (a new list) that refers to the same original objects\n        - helpful for reorganizing object positions like sorting a list or dictionary, but not helpful if you want to change values\n    ![shallow-copy](images/cs220/shallow-copy.png)\n    - deep copy (all levels): slowest but the safest, copies everything including sub-lists and sub-dictionaries — any changes made in the copy is not reflected in the original\n\n### sweigart ch4: lists\n\n- when assigning lists to variables, a *reference* to the list is what’s stored, not the actual list itself\n    - so if two variables point to the same list, then any change made on one variable will reflect on the other\n- python uses **references** when storing values of mutable types, like lists or dictionaries; it will store actual values for immutable types like strings, ints, or tuples\n    - even though lists and dictionaries are passed by reference through functions, they will still be altered directly\n- the `copy` module provides a `copy()` and `deepcopy()` function that makes duplicate copies of dictionaries or lists (and not just references)\n    - if the copy contains lists, use `deepcopy()` because it will copy inner lists\n\n---\n\n## recursive functions\n\n- a tree is an example of recursion where there are **recursive** cases (branches) and **base cases** (leaves)\n- a **recursive** function calls itself, directly or indirectly\n- both iteration and recursion achieve the same purpose but often one is more efficient or easier to implement than the other\n- an example using factorials\n    ```python\n    def fact(n):\n        if n == 1:\n    \t    return 1\n        p = fact(n-1)\n        return n*p\n    ```\n- variables exist in a frame, which are stored in stacks — only the topmost frame is active at a time\n\n### downey ch5: ~~conditions and~~ recursion\n\n- a function that calls itself is a **recursive** function and executing that function is called **recursion**\n- a **base case** is the last call of the recursive function and it does not make another call\n    - if a recursion never reaches a base case, then it’s an **infinite recursion** and the program will never end\n\n### downey ch6: fruitful functions\n\n- return values are passed back up the recursion stack\n- an example with the Fibonacci sequence\n    ```python\n    def fibonacci(n):\n        if n == 0:\n    \t    return 0\n        if n == 1:\n    \t    return 1\n        else:\n            return fibonacci(n-1) + fibonacci(n-2) # calls itself\n    ```\n- sometimes the the function can miss the base case and keep recursing, so it’s good practice to make sure the input to the function is legal\n    - a **guardian** is a chunk of code that protects the code from executing on the wrong arguments\n\n---\n\n## function references\n\n- functions are objects, so they behave like objects\n    - can be referenced by variables, lists, or dictionaries; pass function references to other functions\n- if two different variables are assigned to a function, then both variables can call the function\n    ```python\n    def f():\n        return \"hi\"\n    \n    g = f\n    \n    f() # returns \"hi\"\n    g() # also returns \"hi\"\n    ```\n- function invocations have parentheses, function references *do not*\n- method references can be passed through parameters if the module name is used in the function invocation like, ex: `str.upper(val)` does the same thing as `val.upper()` but using `f = str.upper`, we can call `f(val)`\n- the `sorted()` function has a `key` parameter that allows you to choose what to sort the items by, and the `key` can be a function reference\n    - `attrgetter` is for namedtuples, `itemgetter` is for lists(?)\n\n---\n\n## generator functions\n\n- for recursive functions, make sure the arguments are changing and will at some point hit the base case\n- an eager function will finish execution before returning the end value, whereas a lazy function returns a value at each step and needs to be prompted to return the next value\n- a **generator** can stop and return a value and then execute more code after\n    - use the `yield` keyword\n    ```python\n    def f():\n        yield 1\n        yield 2\n        yield 3\n    \n    for val in f():\n        print(val) # printed once every loop\n    \n    \u003e 1 # goes back to executed yield 2\n    \u003e 2\n    \u003e 3\n    ```\n- multiple instances of the same generator can be executing at the same time\n- the `next()` function is built for generator objects and it will iterate through a generators\n    - by default, generator objects (from yield statements in functions) will create generator instances which can be used by `next()`... I think…\n- an **iterable** is something that can be iterated over, such as sequences like list, tuple, ranges, or `dict.keys()` or `dict.values()`\n    - an **iterator** object is an *iterable* object and can be created for *any iterable object* — it’s a special object with the `next()` function\n- is `iter(x)` works, then `x` is iterable; if `next(x)` works, then `x` is an iterator\n\n---\n\n## error handling\n\n- turn semantic errors into runtime errors\n- a string can be formatted using brackets and `.format()`\n    - `\"area={:.2f}\".format(2.29834)` will print to `2.29` (CHECK)\n- anything that can be used in a boolean statement can also be used in an **assertion** which will throw an error and end the program if it’s false\n- the `try` and `except` blocks let you run code even after it crashes — any errors thrown in the `try` block will prompt the `except` block to run\n    - when an error occurs in a `try` block, the program tries to find the closest `except` block to execute — python will exit functions or loops until it can raise the exception\n- specific exceptions can be specified using `Exception` objects\n    ```python\n    try:\n        print(1/0) # buggy code\n    except Exception as e:\n        print(\"An exception was raised: \" + str(e) + \" \" + type(e))\n    ```\n    - it’s good practice to get very specific about exceptions so the user knows what went wrong\n- to crash the program manually, raise an exception with `raise [Exception](\"error message\")` — the program will search for an `except` clause\n\n### sweigart ch10: debugging\n\n- python raises **exceptions** when the code is wrong but exceptions can also be manually raised using `raise Exception(\"error message\")`\n- **tracebacks** can tell you which line the error appeared on\n- there is a `traceback` module that allows you to manually deal with bugs and output them to log files, which means the program will keep running even if exceptions are thrown in the background\n- an **assertion** is a sanity check to make sure the code is doing what it’s supposed to do, ex: `assert [condition], \"[error message]\"`\n    - if an assertion fails, the error message is displayed and an `AssertionError` is thrown\n\n---\n\n# data science\n## files and directories\n\n- `f = open(\"path\")` will open a file and allow you to read from and write to `f`\n    - always close your files after using them!\n- to read a file, either use `read()` to return the *entire file content* into a string, `next()` to get one line of the file at a time, or `list()` to turn the file contents into a list\n- the `write()` function allows you to write to a file\n- the `os.path.join()` function will join parts of a path together — this is useful because different OS use different forward and backward slashes and this function allows your code to run on multiple platforms\n- **encoding** is taking data and making it readable to the computer, while **decoding** is taking computer-language and making it readable to a human\n- the best way to parse data from large files is to use a generator to turn the data into a stream\n- using `with open(\"path\") as f:` will accomplish the same thing as just using `open()` but it’s faster (because whole data isn’t moved into memory) and the closing clause isn’t required\n- `json.dump(\"file\", [file object])` is the equivalent of `json.dumps(\"file\")` and `f.write()`\n- `data = json.load(f)` is the equivalent of `f.read()` and `json.loads()`\n- `os.path.basename(path)` names the file at the end of the path\n\n### downey ch14: files\n\n- **persistent** programs run all the time and permanently store some of their data — this includes OS and web servers\n- to write to a file, it has to be opened in “write mode” using `open(\"file path\", \"w\")`\n- the **format operator** is `%` and is preceded by a **format sequence**, ex `\"%d\"` is the sequence to format an argument as a decimal integer within the string\n    ```python\n    camels = 42\n    print(\"I have spotted %d camels.\" % camels)\n    \u003e \"I have spotted 42 camels.\"\n    ```\n    - there is also `\"%g\"` for floating-point numbers and `“%s”` for strings\n    - the number of format sequences must match the number of arguments that come after the format operator\n- **directories** are also called folders\n- a **relative path** specifies where a file is located with respect to the “current working directory”, while an **absolute path** specifies how to get to a file from the root of the entire system\n- the `os` module (stands for “operating system”) includes functions for working with files and directories — `os.path.abspath()` to find absolute path, `os.path.exists()` to check if a file or directory exists, etc…\n- a **database** is like a permanent dictionary that organizes data — python offers the `dbm` module to work with databases\n    - each item in the database has an associated **bytes object**\n    - the `pickle` module translates any object into a string to be stored in a database\n- any program that can be launched from the shell, can also be launched from within python using a **pipe object**\n- any file with python code in it can be imported as a module\n\n---\n\n## pandas\n\n- tabular data is data that is organized with tables and columns — using the `pandas` module to order this data is much easier than using lists\n    - Pandas tables are built using `Series` which is a special data structure\n- pandas terminology\n    - *integer position* is a label like 0, 1, 2, that is equivalent to a list’s index\n    - *index* is equivalent to a dict’s key\n- lookup values using indices (keys) `.loc[\"key\"]` or lookup by integer positions (index) `.iloc[\"index\"]`'\n    - negative indexing isn’t supported by Series\n    - new slices are not indexed from 0\n- operations on Series work like vector math — the operation is applied to every element\n    ```python\n    nums = Series([100, 200, 300])\n    nums + 1 # adds one to every element\n    \n    Series([1,2,3]) * 3 # multiples all elements by three\n    \n    Series([10,20]) + Series([3,4]) # results in Series([13, 24])\n    ```\n    - comparisons can also be done (`%`, `\u003e`, `==`)\n- boolean indexing is where you take every value in a Series that matches to `True` in a boolean Series, also called “fancy indexing”\n    ```python\n    letters = Series([\"A\", \"B\", \"C\", \"D\"])\n    bool_series = Series([True, True, False, False)]\n    \n    letters[bool_series]\n    \u003e 0    A\n    \u003e 1    B\n    \n    letters[Series([False, True, False, True])\n    \u003e 1    B\n    \u003e 3    D\n    ```\n- example combining operations and fancy indexing\n    ```python\n    S = Series([1,9,2,3,8])\n    B = S \u003e 5 # Series that evaluates to True at any index where S\u003e5\n    \n    S[B] # filtering out values in S\n    \u003e 1    9\n    \u003e 4    8\n    ```\n- use and `\u0026`, or `|`, not `~` when chaining multiple conditionals for fancy indexing\n- a `DataFrame` is a table of aligned Series\n- calling a comparison function will compare Series even if the indices are mismatched (keys/indices are arranged wrong) — `gt()`, `eq()`, `ge()`, `le()`...\n- a DataFrame is made up of a dictionary of Series but it could be a dict of lists, a list of lists, dict of dicts, list of dicts\n    - the indices can be specified when creating a DataFrame, ex: `DataFrame({data}, index=[\"row titles\"])`\n- to access a single cell in a DataFrame, use `loc[row,col]`\n- to read a CSV file, use `pd.read(\"file path\")` which will automatically add it as a DataFrame\n\n---\n\n## web\n\n- manual downloading is tedious; datasets are difficult to download in complete\n- every machine has an IP address and requests are sent between IPs but nicknames (domains) are easier to remember and are often used in place of IPs\n    - ports are specific locations on the ends of IP addresses\n    - domain: which computer; port number: which program; file name: which data\n- a URL puts together all elements of a request to a machine, ex: `https://en.wikipedia.org:443/wiki/URL`\n- `GET` specifies that we want to get data from the remote server; `POST` means we are uploading data to the server\n- status codes\n    - 200 is good\n    - 404 is the file isn’t available (file not found)\n    - 500 is a server error\n- all data parsed from webpage is formatted in a single string (I think)\n    - the shortcut to turn a .json file into a dict is `[requests.get('url')].json`\n- hypertext is text that is clickable links\n- browser sends a URL (domain, port, file) HTTP request\n- HTML stuff\n    - tags `\u003cb\u003e`, `i`, `u`..., allow you to group pieces of content together and apply special effects\n    - hyperlinks: `\u003ca href=\"[link]\"\u003e\u003c/a\u003e`\n    - images: `\u003cimg src=\"source\"\u003e`\n    - tables: `\u003ctable\u003e`, rows `\u003ctr\u003e`, cell `\u003ctd\u003e`\n- python can convert to html by outputting (`open(html_path, “w”)`) to a .html file\n    - each tag has to be written to the file… it’s not like .csi files in java where the code is mixed\n- BeautifulSoup allows for searching within HTML files\n- the browser takes HTML and generates a DOM (Document Object Model) Tree\n![dom-tree](/images/cs220/dom-tree.png)\n- BeautifulSoup creates a new DOM object when using `BeautifulSoup([data], [parser])`\n    - the `find_all()` function will return a list of all elements with that tag — `find()` returns the first instance\n    - once the elements are found, use the `get_text()` function which will parse the text within those elements\n- if there are nested tags within an element, use the `.children` attribute which will return a list of the children tags of the parent element\n- most websites have a `robots.txt` file which will tell you what’s allowed and disallowed when “crawling” (pulling data from) in their site\n\n### sweigart ch11: web scraping\n\n- **web scraping** is downloading and processing content from the web\n- the `requests` module lets you download files from the web (has to be install from cmd)\n    - `requests.get()` returns a Response object\n        - `raise_for_status()` checks for if the request went through — will produce errors like 404 not found, etc\n- save and write the web page to a file\n    ```python\n    res = requests.get('https://automatetheboringstuff.com/files/rj.txt')\n    res.raise_for_status()\n    playFile = open('RomeoAndJuliet.txt', 'wb')\n    for chunk in res.iter_content(100000): # chunks in bytes\n    \t\tplayFile.write(chunk)\n    \n    playFile.close()\n    ```\n- the Beautiful Soup (bs4) module parses HTML files in the drive\n    - why is web parsing and pandas more tedious to read than the entire two units of this course combined? this is an absolute slog and idk what’s going on even\n    - `exampleSoup = bs4.BeautifulSoup(open(\"example file\"))`\n    - the `select()` method will parse specific CSS syntax, ex: `soup.select(\"div\")` will find all elements named `\u003cdiv\u003e`\n- the `selenium` module can directly control the browser by clicking links and filling in login information\n- the shortcut of performing an action to every element in a list is `new_list = [action for x in old_list]` — called list comprehension\n- defaultdict is a dict object that gives a default value to a key if it doesn’t exist in the dict yet\n\n---\n\n## databases\n\n- SQL databases are collections of named tables where all columns have an enforced type — CSV files are just one table of strings\n    - can keep multiple copies of the same data stored in different ways to make retrieval efficient\n- SQL (structured query language) servers include Oracle, MySQL, SQLite\n- `sqlite3.connect(filepath)` is basically opening the file and will return a Connection object\n    - use pandas to read everything in the db `pd.read_sql(\"SELECT * FROM sqlite_master\", [connection obj])` and save it into a DataFrame to parse\n- SQL has different type names: `INTEGER`, `REAL`(float), `TEXT`(str)\n- `CREATE TABLE` signifies new table and will be followed by the table name\n- to get data and narrow down to to specific cells, start with `SELECT [ ] FROM [table name];` and follow in the order below\n    - `SELECT` which columns\n    - `FROM` which table\n    - `WHERE` which rows; filtering in the original table\n    - `GROUP BY` groups into categories (buckets)\n    - `HAVING` which rows, filters from the sorted groups above\n    - `ORDER BY` sorts the data — `ASC` ascending, `DESC` descending\n    - `LIMIT` how many rows\n- the `AS` keyword creates a new column and can be used later\n- aggregate queries\n    - `COUNT()` counts the number of items in a col\n        - use `DISTINCT` to remove duplicates\n    - `SUM()` adds entire col together\n    - `AVG()` averages a col\n![sql-sequence](/images/cs220/sql-sequence.png)\n\n---\n\n## plotting\n\n- pandas Series and DataFrames integrates with matplotlib\n    - `[Series].plot.pie(figsize=(width, height), color=\"\")` makes a pie chart out of a Series\n    - `[s,df].plot.bar()` makes a bar plot\n        - the Series object can be directly altered before it’s plotted, ex: `([Series] / 100).plot.bar()` will divide all elements in the Series by 100 and plot accordingly\n        - the DataFrame bar plot takes a parameter `stacked=` which will make a stacked bar plot\n    - `[DataFrame].plot.scatter(x=\"\", y=\"\")` makes a scatter plot out of a DataFrame\n        - `s=` size of the points\n        - `c=` color of the points\n            - `vmin` takes a floating-point value that restricts the b/w of the plot points…\n        - `marker=` shape of the points `\"o\"` `\"+\"` `\"^\"` `\"v\"`\n        - set the limits of x and y axes using `xlim=` and `ylim=`\n    - `[s,df].plot.line()` line plot for Series or DataFrame\n        - the index is the x-axis unless otherwise specified\n            - for Series, use `s.sort_index()`\n- change default plot settings (like font size) by calling `matplotlib.rcParams[\"setting\"]`\n- once a plot is made, it returns an AxesSubplot object which can be tweaked\n    - `plot.set_title(\"title\")`\n    - `plot.set_ylabel(\"label\")`\n    - `plot.set_xticklabels(list([Series].index), rotation=)` sets the orientation of the x-axis labels\n    - `plot.splines[”right”, “top”, “bottom”, “left”].set_visible[True, False]`\n        - splines are the edges of the graph\n- it’s good practice to make a function that makes your plots look the same\n    - the main plot can be divided into subplots which you can specify settings for\n    - `fig, ax = plt.subplots()` and then customize the axis\n- set the index of a DataFrame using `[DataFrame].set_index()` to have custom tick labels\n    - tick positions also need to be set with `[df.plot.line()].set_xticks([list])`\n- define a custom header of a DataFrame using the `name=` parameter\n- to make a scatter plot for multiple classes, you have to loop over each class while plotting on the same `AxesSubplot`\n    - define a list of colors to change colors as you loop through classes `colors = []`\n    - add a legend using `label=` and the title of the class\n- use `cumprod()` to find the cumulative product\n- with large amounts of data, only present the important percentiles (using `.quantile(percentile=, axis=[column])`)and not the whole set of data\n- drop NaN values using `dropna()`\n- verify that data points aren’t being cut off in a plot using `assert` statements to compare `xlim` and `ylim` with the max values of x and y axes\n    - ex: `assert [df[axis]].max() \u003c= [ax].get_xlim()[?]` 0 or 1…?\n- log base 10 refocuses into how long the number is (how many 0s) instead of digits — logarithmic scale is used so small values aren’t “brushed aside” when plotting\n- `plot.subplots()` can take a parameter `ncols=` and `nrows=` which will create multiple AxesSubplot objects\n    - to ensure the same y-axis across multiple graphs, use the parameter `sharey=True`\n\n---\n\n## randomness\n\n- `random.choice([list])` returns a random value from the list (using the `random` module) — sampling with replacement\n    - `random.choices([list], size=)` returns `size` random values — `size` can also be a tuple to generate multidimensional arrows (row, col)\n    - takes a parameter `p=` where the probability can be predetermined\n- how do we know if something is really random? look at a large sample size\n- seeds are predetermined random sequences … like Minecraft\n    - it’s easier to debug errors that depend on randomness if the randomness can be controlled through seeds\n- large difference in a small data set, or a small difference in a large data set means it might not be random","lastmodified":"2022-10-14T05:23:27.484421268Z","tags":null},"/notes/cs61a":{"title":"CS 61A","content":"Self-paced course taken summer '22, linked [here](https://inst.eecs.berkeley.edu/~cs61a/fa21/). Beginner programming course using Python -- teaches data abstraction, ... Great focus on shortcuts and problem-solving with code; has hints of competitive coding strategies. Texts used include *Composing Programs* by John DeNero. Completed homework linked [here](https://github.com/heyitssqueak/classes/tree/master/cs61a).\n\n# content\n\n## functions\n\n### ch1.1: getting started\n\n- Python devs emphasized human interpretability of Python code — easy to read/understand\n- an interactive session is signaled by the `\u003e\u003e\u003e`\n- statements describe actions; expressions describe computations\n\n### ch1.2: elements of programming\n\n- any powerful programming language should be able to describe data and functions, or, “have data and process it”\n- expressions describe a computation and evaluates it to a value\n    - infix notation is when operators (`+`, `-`, `*`, `/`) appear between operands (the numbers)\n    - all expressions can be generalized to **function notation**\n- a **call expression** applies a function to some arguments\n- not all functions are available by default and many have to be imported through **modules**\n- `=` is the assignment operator, which matches names to the results of compound operations or to functions\n    - the names are remembered by Python’s interpreter, which means that the interpreter has some kind of memory — the memory is an **environment**\n- nested function calls repeated the same procedure until the expression is evaluated: first evaluate the operator (function) and then its operands (arguments)\n- **pure functions** have an input and an output and will *always return the same output for the same input*\n    - can’t have side effects or change behavior over time, making them reliable\n    - simpler to test\n- **non-pure functions** change the state of the interpreter or computer, ex: `print`\n- a function that doesn’t specify a return value will return `None`\n\n### lecture\n\n- every expression in Python is generalized to *function call notation*\n- any call expression is made up of an operator and its operands, which are also expressions (possibly made up of more operators and operands)\n\n![call expression tree](/images/cs61a/call-expression-tree.png)\n\n- three ways to bind values to names: importing modules, assignment, and `def` statements (functions)\n- with a frame, a name can only be bound to one value\n- Python evaluates all the expressions to the right of the assignment operator `=`, and then it binds the resultant values to the name(s) on the left\n- **abstraction** is the process of naming something complex and treating it as a whole entity without worrying about its details\n    - functions are a form of abstraction:\n        ```python\n        def \u003cname\u003e(\u003cformal parameters\u003e):\n            return \u003creturn expression\u003e\n        ```\n        - the function *signature* (first line) defines how many arguments a function will take — the signature is the name of the object\n        - the function *body* (remainder) is where the computational process happens\n- an *environment* is a sequence of *frames*\n    - a **frame** is a bit of a memory that keeps track of what names mean (it’s also called a scope)\n    - any name evaluates to the assigned value in the closest frame, starting with the local frame and working towards the global frame\n- to use a local variable from the global frame, you have to return the local variable first (assuming it’s a function call)\n\n---\n\n## control\n\n### ch1.3: defining new functions\n\n- to define a function is to give a name to a compound operation, which allows the operation to be referred to\n- the `def` statement and the assignment operator `=` bind names to values — any previously bindings are lost\n- bindings exist in *frames* which are layered\n    - a local frame is created every time a function is called\n        - a name only exists in that frame for as long as the frame exists, ie once the function call is over, any bindings within the function will disappear\n- the **scope** (existence) of a local name is limited to its function or its frame\n- functional abstraction is the idea that the only thing that matters about a function is its return value, and not the process which that value is computed\n    - three core values to functional abstraction: *domain*, or the set of arguments of a function; *range*, or the set of values it can return; *intent*, the relationship between the inputs and outputs\n\n### ch1.4: designing functions\n\n- a function should have exactly one job\n- don’t repeat yourself — if you are copy-pasting code, it can probably be turned into a function\n- triple quoted docstrings at the top of a function body typically describe what the function does\n    ```python\n    def pressure(v, t, n):\n        \"\"\"Compute the pressure in pascals of an ideal gas.\n    \n        Applies the ideal gas law: http://en.wikipedia.org/wiki/Ideal_gas_law\n    \n        v -- volume of gas, in cubic meters\n        t -- absolute temperature in degrees kelvin\n        n -- particles of gas\n        \"\"\"\n        k = 1.38e-23  # Boltzmann's constant\n        return n * k * t / v\n    ```\n- default function values can be specified in the function signature\n\n[stopped reading the textbook lol]\n\n### lecture\n\n- Python’s interactive interpreter will print any value returned from an expression or function that isn’t `None`, which represents nothing\n- **pure functions** return values and have the same output for the same input\n- **non-pure functions** have an input and output but something else happens before the output, like some text being printed to the terminal\n- a `def` statement is how a function is created — includes the signature and body, which are bound to the name of the function\n    - the frame isn’t created until the function is called\n- multi-frame environments consist of a global frame and then local frames\n    - a *name* evaluates to the earliest assigned instance of a value to that name, whether that be in the local frame or otherwise\n- there are two kinds of division\n    - `/` is called **true division** which divides like normal, ex: `2013 / 10` evaluates to `201.3`\n    - `//` is called **floor division** which rounds down to the nearest integer, ex: `2013 / 10` evaluates to `201`\n- to return multiple values from a function, use a comma\n- Python can run in a file, run in the interactive mode, or run a file in interactive mode\n- Python can run an interactive session by taking code from a function’s docstring\n    ```python\n    def divide_exact(n,d):\n        \"\"\"Return the quotient and remainder of dividing n by d.\n    \n        \u003e\u003e\u003e q, r = divide_exact(2013, 10)\n        \u003e\u003e\u003e q\n        201\n        \u003e\u003e\u003e r\n        3\n        \"\"\"\n        return floordiv(n, d), mod(n, d)\n    \n    python3 -m doctest -v [\"filename\"]\n    ```\n- use the `if`, `elif`, `else` to execute a suite (set of statements after a header) that evaluate to true to a boolean statement\n- **boolean statements** will always evaluate to either `True` or `False`\n    - false values: `False`, `0`, `\"\"`, `None`\n    - true values: anything that isn’t false\n- **iteration** allows us to repeat stuff\n    - for a `while` loop, we evaluate the header’s boolean expression, and then execute the following suite and evaluate the header again\n\n---\n\n## higher-order functions\n\n- characteristics of functions\n    - **domain**: the set of all inputs as arguments\n    - **range**: the set of all outputs\n- each function should have exactly one general job\n- an `assert` keyword can be followed by a boolean expression that will throw an error if the expression evaluates to false\n    - this is useful for checking if given arguments are within specifications\n- a higher-order function is a **first-class value**, and can take another function as an argument, or can also be returned as a return value\n    ```python\n    def make_adder(n):\n        \"\"\"Return a function that takes one argument k and returns k + n.\n    \n        \u003e\u003e\u003e add_three = make_adder(3)\n        \u003e\u003e\u003e add_three(4)\n        \"\"\"\n        def adder(k):\n        \treturn k + n\n        return adder\n    ```\n    - the function `adder` is returned from `make_adder` and assigned to `add_three` with `n=3`\n- **lambda expressions** are expressions that evaluate to *functions* — use the `lambda` keyword, ex: `square = lambda x: x*x` ⇒ `square(4)` evaluates to 16\n    - the function name can be skipped and directly called, ex: `(lambda x: x*x)(4)` evaluates to 16\n- lambdas can’t use conditionals while `def` statements can; `def` statements give functions a name while lambdas don’t (it’s just called a lambda)\n- `and` and `or` are logical operators which don’t require all statements to be checked to evaluate fully\n    - for `and`, if the first statement is false, then the whole statement is false\n    - for `or`, if the first statement is true, then the whole statement is true\n        - ex: `return (n==0) or (1/n != 0)`, the expression wouldn’t throw a zero-division error because `n==0` evaluate to true first so true is returned without considering the second expression\n- a conditional expression can take the form `\u003cconsequent\u003e if \u003cpredicate\u003e else \u003calternative\u003e`\n    - the `\u003cpredicate\u003e` is evaluated first, and if it’s true, the expression evaluates to the `\u003cconsequent\u003e` value\n    - if `\u003cpredicate\u003e` is false, then the expression evaluates to `\u003calternative\u003e`\n    ```python\n    print(\"cons\" if 2==2 else \"alt\")\n    # prints cons\n    print(\"cons\" if 2==3 else \"alt\")\n    # prints alt\n    ```\n    \n---\n\n## environments\n\n- a **higher-order function** is a function that can take another function as an argument, or returns another function as a return value\n- a return statement brings information from a local frame into a global frame (or similar)\n- the parent frame of a frame created from a *returned function* is the *frame where that function was created*, which means that function has access to its parent frame values\n    - below: `make_adder` returns a function `adder` in frame `f1`; when the new `add_three` function (a sub-function of `adder`) is called, it can access values in its parent frame, `f1`\n\n![python tutor frames](/images/cs61a/parent-frames.png)\n\n- the environment created by calling a top-level function consists of a local frame followed by the global frame\n- a function can return itself, which can lead to the same function being called on multiple arguments in the same line of code\n    - the function does not run forever because the return value is only a function object, and not a call to that function\n    ```python\n    def print_all(x):\n        print(x)\n    \treturn print_all\n    \n    print_all(1)(3)(5)\n    \n    # 1\n    # 3\n    # 5\n    ```\n- **currying** is transforming a multi-argument function into a single-argument, higher-order function\n    - when calling `add_three`, it has access to the `f2` and `f1` frames which store the variables `x` and function `f`\n\n![currying](/images/cs61a/currying-frames.png)\n\n---\n\n## design\n\n- **abstraction** is giving a name to a process and referring to it as a whole and not worrying about the details of the process\n    - function names don’t matter for correctness of a program, but they matter to humans :(\n- a **docstring** is the best way to document a function’s purpose\n- a **syntax error** is detectable before the program starts executing and they are caused by errors in the form/language of the code, ex: unclosed parentheses\n- a **runtime error** is detected by the interpreter while the program is executing, ex: `TypeError` which occurs when math doesn’t work out between objects of different types…\n- a **logical error** isn’t detected at all, the program runs but doesn’t do as expected\n- a **decorator** is a function that goes at the top of a function, which is called on the function\n    ```python\n    @trace\n    def triple(x): # calls trace on triple\n        return 3*x \n    ```\n\n---\n\n## recursion\n\n- a **recursive function** is a function that calls itself\n    - uses conditional statements to check for base cases — usually doesn’t end in a recursive call, and a value is directly returned\n    - each call to the function will solve a simpler problem than the last call (smaller `n`)\n- mutual recursion is when two different functions call each other, ex: Luhn algorithm\n- iteration is a special case of recursion\n    - to convert from recursion to iteration, you need to figure out what *state* has to be maintained after each recursive call (which should match to each iterative call…)\n\n---\n\n## tree recursion\n\n- until a value is returned from a function call, that call is not completed\n- statements can happen before and after recursive calls\n- **tree-shaped recursion** happens when the body of a recursive function calls itself more than once\n    - ex: computing a Fibonacci number `n` requires finding the Fibonacci number at `n-1` and `n-2`\n    ![fib tree recursion](/images/cs61a/fibtree.png)\n- some problems are best resulted by a recursive function…\n- counting partitions example — looks like a competitive programming problem\n    - Given a number `n`, using parts of up to size `m`, find the number of ways that `n` can be represented as a sum of positive integer parts with size `m` in increasing order; ex: `count_partitions(6,4)` means we should find all the possible ways that we can form 6 using parts of up to size 4. (2+4, 1+1+4, 1+2+3, 1+1+2+2…)\n    ```python\n    def count_partitions(n,m):\n        if n == 0:\n            return 1\n        elif n \u003c 0:\n            return 0\n        elif m == 0:\n            return 0\n        else:\n            with_m = count_partitions(n-m, m)\n            without_m = count_partitions(n, m-1)\n            return with_m + without_m\n    ```\n\n---\n\n## containers\n\n- a **list** is a built-in data type that can hold a group of any objects\n    - has indexing using brackets and `len` function for the length of the list\n    - multiplying a list forms a repetition of the list, while adding two lists together merges them into one list\n    - to test if an element appears in a *container*, use the `in` keyword\n        - if the element is nested too deeply (more than one layer…?) then `in` can’t find it — it only looks at each element of the list\n- a `for` statement can iterate through a list or a range of numbers\n    ```python\n    for \u003cname\u003e in \u003cexpression\u003e:\n        \u003csuite\u003e\n    ```\n    - a sequence can be unpacked in the `for` statement, ex: each value in the nested list `pairs=[[4,4],[3,5],[1,2]]` can be assigned to a variable using `for x, y in pairs`\n- a **range** is also a sequence type, like a list, but represent consecutive integers\n    - convert a range to a list using the `list` function\n- list comprehensions are shortcuts to generate new lists from existing lists\n    ```python\n    odds = [1,3,5,7,9]\n    evens = [x+1 for x in odds] # list comprehension\n    # [2,4,6,8,10]\n    \n    div_25 = [x for x in odds if 25 % x == 0] # only added to the list if the condition evaluates true\n    # [1,5]\n    ```\n- **strings** are a way of representing data\n    - `\\n` represents a new line\n    - `len` and indexing can also be used\n    - `in` evaluates to substrings which means you can look for whole words\n\n---\n\n## sequences\n\n- a method for combining data values satisfies the **closure property** if the *result* of the combination can be itself combined using *the same method*\n    - two lists can be combined using the `+` operator, whose result can be added to another list!\n    - important for creating hierarchical structures\n- **slicing** is an operation that can be performed on lists and ranges — it uses the `[lower:upper]` notation, ex: `\"berkeley\"[0:3]` returns `\"ber\"`\n    - always creates new objects\n- `sum` will add all non-string values in a list together with an optional parameter as the start value of the summation\n- `max` will return the maximum value of the sequence and takes an optional function `key` as a parameter that can be applied to all values to find the max of that function, ex: `max([1,2,3,4,5], key=lambda x: 7-(x-4)*(x-2))` returns `3`\n- `all` returns if all values in an iterable will return true\n\n---\n\n## data abstraction\n\n- abstract data types allows us to manipulate compound objects as units, which separates how data is represented and manipulated\n    - **constructors** build abstract data values\n    - **selectors** work with parts of the abstract data values\n- a list can be unpacked, ex: `x,y = [1,2]` where `x=1` and `y=2`\n- abstraction barriers allow parts of the program to take advantage of other parts of the program without anything causing errors between them — certain parts only use certain functions…\n\n![abstraction](/images/cs61a/abstraction.png)\n\n- data types guarantee that the constructor and selectors will work together to show the right behavior\n- data abstraction can be implemented as functions\n- **dictionaries** are a built-in data type that assigns a value to a key — sequence of keys\n    - created using curly brackets, ex: `{key:value}`\n    - look up values by looking up the name of the key between square brackets (indexing with key names)\n    - the value in a dictionary can be any object\n    - keys cannot be repeated and the key itself can’t be a list or dictionary\n- dictionary comprehensions can generate dictionaries given a ruleset\n    ```python\n    {\u003ckey exp\u003e: \u003cvalue exp\u003e for \u003cname\u003e in \u003citer exp\u003e if \u003cfilter exp\u003e}\n    \n    {x * x: x for x in [1,2,3,4,5] if x \u003e 2}\n    # {9: 3, 16: 4, 25: 5}\n    ```\n\n---\n\n## trees\n\n- **trees** represent hierarchical relationships\n    - a tree has a root and a list of branches (which are subtrees)\n    - a leaf is a tree without any branches\n\n![tree diagram](/images/cs61a/tree-diagram.png)\n\n```python\ndef tree(label, branches = [])\n    for branch in branches:\n        assert is_tree(branch), \"branches must be trees!\"\n    return [label] + list(branches)\n\ndef label(tree):\n    return tree[0]\n\ndef branches(tree):\n    return tree[1:]\n\ndef is_tree(tree):\n    if type(tree) != list or len(tree) \u003c 1:\n        return False\n    for branch in branches(tree):\n        if not is_tree(branch):\n            return False\n    return True\n\ndef is_leaf(tree)\n\t\treturn not branches(tree)\n```\n- functions that take trees as inputs or returns trees as outputs are **tree-recursive**\n    - example with a function that counts the leaves of a tree\n        ```python\n        def count_leaves(t):\n            \"\"\"Count the leaves of a tree.\"\"\"\n            if is_leaf(t):\n                return 1\n            else:\n                branch_counts = [count_leaves(b) for b in branches(t)]\n                return sum(branch_counts)\n        ```\n- information can either be passed through recursive calls as arguments or they can be manipulated as return values\n\n---\n\n## mutability\n\n- an object is supposed to behave like what it represents (information)\n    - it has attributes, which are like details of the object\n    - methods are accessed using a dot expression and are applied on the object\n    - a type of object is called a **class**\n- functions are meant to do one thing; objects are meant to do many related things\n- strings are objects, with methods `.upper` `.lower`, attributes `len`\n- an object’s value can change over time\n    - lists can be mutated (changed) using `.remove` `.pop` `.append` etc, which will be reflected in any copies of that list\n    - mutable objects include lists and dictionaries\n- **tuples** are immutable sequences and are created using parentheses `()`\n    - tuples can be added and sliced like lists\n    - they are immutable, so they *can* be used as keys (unless they contain lists or dicts)\n- an immutable sequence can still change if it has a mutable value as an element\n- the identity operator is `is` and will evaluate to true if both expressions evaluate to the same object — this is different from equality (`==`) which is true when both expressions evaluate to the same *value*\n    - when two things aren’t identical, changes in one won’t affect the other\n\n---\n\n## syntax\n\n- **syntax** is like the rules for how a language works\n- read plaintext files in Python using `open` and `readlines`\n- useful string methods: `.strip` `.split` `.replace`\n- language models describe how likely some text would appear in a sentence or next to some words (generating sentences by looking at huge samples of data)\n\n---\n\n## iterators\n\n- **iterators** represent sequential data, which provides access to elements in some order\n    - `iter` returns an iterator of some iterable value\n    - `next` returns the next value in an iterator\n- after Python 3.6, the order of items in a dictionary is the order which they were added\n- useful dictionary methods: `.keys` returns a list of keys, `.values` returns a list of values, `.items` returns a list of tuples containing key and value\n- if a dictionary key is changed while it’s being iterated over, then the iterator is now invalid — doesn’t apply if a dictionary value is changed\n- `for` statements can iterate over iterators\n- built-in functions for iteration\n    - `map(func, iterable)` applies `func` to `x` for `x` in `iterable`\n    - `filter(func, iterable)` iterates through `x` in `iterable` if `func` is true\n    - `zip(iter_1, iter_2)` iterates through pairs\n    - `reversed(seq)` iterates in reverse order\n    - `list` `sorted` `tuple`\n- lazy computation is useful if you need to calculate lots of values but don’t need all the values immediately\n- calling `iter` on an iterable just returns that iterable object\n\n---\n\n## generators\n\n- a **generator** is a special kind of iterator, returned from a generator function which uses the `yield` keyword instead of `return`\n    - the generator object can yield (return) multiple values and the generator function iterates through them\n    ```python\n    def plus_minus(x):\n        yield x\n        yield -x\n\n    t = plus_minus(3) # t is a generator object\n    next(t) #  3\n    next(t) # -3\n    ```\n    - the body of the generator function isn’t called until `next` is called\n- `yield from` just yields all the values in an iterator — is shorthand for using `for` statements\n- example of finding all substrings of a string… looks like a competition problem\n    ```python\n    def prefixes(s):\n        if s:\n            yield from prefixes(s[:-1])\n            yield s\n    \n    def substrings(s):\n        if s:\n            yield from prefixes(s)\n            yield from substrings(s[1:])\n    ```\n- if there is a `return` statement in a generator, it won’t yield anything after\n- repeating the partitions problem but using `yield`\n    ```python\n    def partitions(n, m):\n        if n \u003e 0 or m \u003e 0:\n            if n == m:\n                yield str(m)\n            for p in partitions(n-m, m):\n                yield p + \" + \" + str(m)\n            yield from partitions(n, m-1)\n    ```\n\n---\n\n## objects\n\n- **object-oriented programming (OOP)** is a way of organizing programs so that similar information and behavior are grouped together, and can be changed without affecting other parts of the program (abstraction)\n- a **class** is a template for its instances, which are objects of that class\n    - all objects part of a class will have the same attributes and behaviors\n- `class` statements let you create a new class, which means you can create your own objects\n    ```python\n    class \u003cname\u003e:\n        \u003csuite\u003e\n    ```\n    - assignments and `def` statements within the `\u003csuite\u003e` create attributes of the class\n- when a class is called, a new instance of the class is created (a new object)\n    - the `__init__` method is first called with an argument `self` and any other specified arguments\n    ```python\n    class Account:\n        def __init__(self, account_holder):\n            self.balance = 0\n            self.holder = account_holder\n    ```\n- binding an object to a new name using assignment does *not* create a new object…\n- **methods** are functions that are defined in a class\n    ```python\n    class Account: \n        def deposit(self, amount):\n            self.balance = self.balance + amount\n\n        def withdraw(self, amount):\n            if amount \u003e self.balance:\n                return \"Insufficient funds.\"\n            self.balance = self.balance - amount\n            return self.balance\n    ```\n- `self` is referring to an (arbitrary?) instance of the class, similar to `this` in Java\n- any object has access to its attributes (via the `self` keyword) — they can be accessed using *dot notation* `\u003cexpression\u003e.\u003cname\u003e`\n    - can also get attributes using function `getattr(obj, attr)`\n- a **method** is an attribute that’s a function\n    - **bound methods** group together the function and the object which the method is called on\n\n![instance and class methods](/images/cs61a/method-types.png)\n\n- class attributes are shared across the class — if it changes, then it changes for every instance of the class\n    ```python\n    class Account:\n        interest = 0.02 # class attribute\n    ```\n\n---\n\n## inheritance\n\n- all objects, including classes, have attributes\n    - an attribute of an instance is called an *instance attribute*, ex: `\u003cinstance\u003e.attribute =`\n    - attribute of a *class* of an instance is called a *class attribute*, ex: `Class.attribute =`\n        - changing class attributes doesn’t change individual attributes\n- **inheritance** is a method for relating classes together\n    ```python\n    class \u003cname\u003e(\u003cbase class\u003e):\n        \u003csuite\u003e\n    ```\n    - the subclass can share attributes with its base class\n    - methods from base classes can be called by calling the base class’s attribute\n- **composition** is when one object has another object as an attribute\n- inheritance: is-a relationship, ex: `CheckingAccount` is a `Account`; composition: has-a relationship, ex: `Bank` has a `Account`\n- **multiple inheritance** is when a subclass has multiple base classes — should be used sparingly\n\n---\n\n## representation\n\n- the `str` string representation is designed for human readability, while the `repr` string representation is designed for the Python interpreter\n    - calling `repr` on a value will show what would print out in an interactive session, ex: `repr(min)` shows `'\u003cbuilt-in function min\u003e'`\n- **string interpolation** is when you evaluate a string literal with some expressions\n    - add `f` before the string and enclose any expressions in curly braces, ex: `f'pi starts with {pi'`\n- a **polymorphic function** is a function that applies to many types of data (such as `str` and `repr`)\n- an **interface** is a set of shared messages (attributes look-ups that elicit similar behaviors even on different classes/types)\n- certain method names are special because they have a built-in behavior — denoted by two underscores, like `__init__`, `__repr__`\n    - adding two instances of user-defined classes: `__add__` or `__radd__` but you have to define it\n\n---\n\n## recursive objects\n\n- a **linked list** is either empty or it just holds a single value with a reference to the rest of the list — it’s just like a number line thing\n\n![linked list diagram](/images/cs61a/linked-list-diagram.png)\n\n- the rest attribute of a linked list can be assigned to an earlier element in that list, which creates a loop in the list\n- *rerouting* in a linked list is reassigning the rest attribute which would change the list (either when you’re adding or removing instances)\n- a path (for a tree data structure) is a sequence of nodes that leads to a certain node\n- *pruning* is removing subtrees from a tree\n\n---\n\n## efficiency\n\n- it’s important for programs to not take up too many resources while running\n- **memoization** is the idea that you should remember the results that have been computed previously (so they can be used later)\n    ```python\n    def memo(f):\n        cache = {}\n        def memoized(n):\n            if n not in cache:\n                cache[n] = f(n)\n            return cache[n]\n        return memoized\n    ```\n    \n    - only pure functions can be memoized\n- complexity can sometimes mean better efficiency\n- there is *linear* and *logarithmic* orders of growth, or how long the function takes to run as the numbers get larger — also *quadratic* for pairs of inputs, or *exponential* for recursion, and *constant* growth means the input doesn’t affect the time\n    - there is a notation for each order of growth, called big-theta (or big-O for upper bound) notation\n    - exponential: $O(b^n)$; quadratic: $O(n^2)$; linear: $O(n)$; logarithmic: $O(\\log n)$; constant: $O(1)$\n- the length of objects/programs take up space (memory), but so do active frames and environments\n    - an active environment includes current active function calls, including their parents (this might be why recursion is slow?)\n\n---\n\n## decomposition\n\n- **modular design** is when a big program is broken up into smaller, independent parts — parts can be swapped out and implement abstraction barriers\n    - a component is meant to do one thing and can be developed and tested independently\n    - one part should know as *little as possible* about the other parts, so changes in one component won’t break everything else\n- read json files in Python by importing the `json` module and then opening the file using `open` and reading the lines\n- given two, non-repeating sorted lists, advance the iterator over the smaller value until a pair is found, then iterate both, until the end of the list is reached (linear time)\n\n---\n\n## users - todo\n\n---\n\n## scheme\n\n- **scheme** is a dialect of lisp\n- programs consists of expressions\n    - primitive: 2, 3.3, true, +\n    - combinations: `(quotient 10 2)` `(not true)`\n- procedures = functions\n- the built-in `?` operator can evaluate if something is of a certain type — `(zero? 0)` is `#t`, `(zero? 1)` is `#f`\n- special forms\n    - `(if \u003cpredicate\u003e \u003cconsequent\u003e \u003calternative\u003e)`\n    - `(and \u003ce1\u003e ... \u003cen\u003e)`, `(or \u003ce1\u003e ... \u003cen\u003e)`\n    - symbols: `(define \u003csymbol\u003e \u003cexpression\u003e)`\n    - procedures: `(define (\u003csymbol\u003e \u003cformal parameters\u003e) body)`\n        ```scheme\n        (define (sqrt x)\n            (define (update guess)\n                (if (= (square guess) x)\n                    guess\n                    (update (average guess (/ x guess)))))\n            (update 1)\n        ```\n    - `(lambda (\u003cformal-parameters\u003e) \u003cbody)`\n- `cond` is like an if/else or a switch statement\n    ```scheme\n    (cond ((\u003e x 10) (print 'big)) ; only one is executed\n          ((\u003e x 5)  (print 'medium))\n          (else     (print 'small)))\n    ```\n    \n- `begin` allows you to add multiple subexpressions to be evaluated if a condition evaluates to true…\n- `let` binds a temporary symbol to a value, which is gone after it is used — `define` is used for permanent things\n- every scheme list is a linked list\n    - `cons` creates a linked list\n    - `car` returns the first element of the list\n    - `cdr` returns the rest of the list — usually returns a list too?\n    - `nil` is the empty list\n- `list` just builds a list without needing to use `cons` but the underlying `car` `cdr` is still the same\n- symbols refer to values, but how do we refer to symbols? by using `'` quotation, ex: `(list 'a 'b)` makes `(a b)`\n    ```scheme\n    (define a 1)\n    (define b 2)\n    (list a b)\n    ; (1 2)\n    (list 'a 'b)\n    ; (a b)\n    (list 'a b)\n    ; (a 2)\n    ```\n    - a symbol can be used as a part of the code without calling the actual function\n\n---\n\n## exceptions\n\n- an example of how symbols can be used\n    ```scheme\n    (list 'quotient 10 2)\n    ; (quotient 10 2)\n    \n    (eval (list 'quotient 10 2))\n    ; 5\n    ```\n- build lists to write constructed code and just call `eval` when you need to run the code\n    - using symbols tells scheme that we don’t want to evaluate the expression yet\n- quasiquotation is when you can use a special backtick quote symbol ``` and parts of the quote can be unquoted with `,`\n    - quote: `'(a ,(+ 3 1))` \u003e `(a (unquote (+ 3 1))`\n    - quasiquote: ``(a ,(+ 3 1))` \u003e `(a 4)`\n- `while` statements don’t exist in scheme so you have to iterate and you recursion\n- quoting, unquoting, and the structure of lisp/scheme allow for the computer to easily generate programs\n- Python raises exceptions when errors occur, which can also be handled — unhandled exceptions will halt Python and print stack traces\n    - `assert` statements — ignore assertions using the `-O` flag\n    - `raise` statements are exceptions with custom debug messages\n- `try/except` suites can handle exceptions when they are expected\n    - the `try` suite is executed first, and if an unhandled exception is raised and inherited from the exception class in the `exception` suite, then the `exception` suite is executed\n    ```python\n    try:\n        \u003ctry suite\u003e\n    except \u003cexception class\u003e as \u003cname\u003e:\n        \u003cexcept suite\u003e\n    ```\n    \n---\n\n## calculator\n\n- an **interpreter** is a program that takes code as an input and executes the code to get the desired output\n- **machine languages** are languages that are interpreted by the hardware — instructions based on the circuitry of the CPU\n    - hard to program, no abstraction, usually refer to specific memory addresses\n- **high-level languages** are statements and expressions that are translated into another language to be executed later\n    - provides abstraction, functions, objects\n    - no hardware designed for these languages\n- some languages are designed for a specific application — Erlang was designed for concurrent communication, MediaWiki was designed for static web pages\n- languages have syntax (statements/expressions) and semantics (execution/evaluation)\n    - need to have specification or a canonical implementation\n- a **parser** takes text and returns expressions\n\n![parse order](/images/cs61a/parse-order.png)\n\n- recursive syntactic analysis is a process of inspecting `k` tokens to decide how to proceed, for a fixed `k`...\n    - the base case is symbols and numbers, any other calls are sub-expressions\n- the `Pair` class represents Scheme pairs and lists — has first and second attributes\n    - will be a well-formed list if second is nil or a well-formed list\n- primitive (numbers) expressions evaluate to themselves while call expressions evaluate to its arguments modified by an operator\n- **read-eval-print loop** allows a person to interact with the code, ie Python interactive interpreter\n    - exceptions are handled in one place and should not stop the interactive interpreter\n\n---\n\n## interpreters\n\n- an `eval` evaluates both primitive and combined expressions, but will call a function `apply` on the combined expressions\n    - `apply` will also call `eval` to evaluate the body of custom functions which makes mutually recursive functions\n\n---\n\n# homework\n\n### disc 01: control, environment diagrams\n\n- **conditional statements** let programs execute different lines of code depending on what conditions are true or false\n    - general form of an `if` statement\n        ```python\n        if \u003cconditional expression\u003e:\n            \u003csuite of statements\u003e\n        elif \u003cconditional expression\u003e:\n            \u003csuite of statements\u003e\n        else:\n            \u003csuite of statements\u003e\n        ```\n    - general form of a `while` loop\n        ```python\n        while \u003cconditional clause\u003e:\n            \u003cstatements body\u003e\n        ```\n        \n- `not` `and` `or` are boolean operators that manipulate boolean expressions\n- a `def` statement defines a function object\n    - call expressions apply functions to arguments\n\n### lab 01: variables \u0026 functions, cont\n\n- `\u003e\u003e\u003e True and 12` displays `12`\n- `\u003e\u003e\u003e False or 0` displays `0` (I assume because the statement evaluates to `False` and `0` is the last evaluated expression?)\n- `\u003e\u003e\u003e not 10` displays `False` because `10` is a truthy value\n- `\u003e\u003e\u003e not None` displays `True` because `None` is a falsey value\n- `\u003e\u003e\u003e True and 0` displays `0` (because last evaluated expression is `0`?)\n- `\u003e\u003e\u003e 0 or False or 2 or 1/0` displays `2` because `2` is the expression that makes the statement be true\n- I think that what gets printed by the interpreter is the last evaluated value that makes the expression be true or false!\n- use `python3 ok -q [\"question\"] -i` to open an interactive terminal for the question\n- use `python3 ok -q [\"question\"] --trace` to look at an environment diagram for the question\n\n### lab 02: higher-order functions, lambda expressions\n\n- transforming a function `f(x,y)` into `g(x)(y)` is known as currying\n    ```python\n    def lambda_curry2(func):\n        return lambda x: lambda y: func(x,y)\n    ```\n    \n- sometimes, trying to refer to a variable in the parent frame won’t work — use the `nonlocal` keyword to reframe the variable\n    - idk why it doesn’t work\n- Church numerals…\n\n### disc 02: higher-order functions, self reference\n\n- a lambda expression doesn’t return anything until the lambda is called\n- the parent of any function is the frame where the function is defined — variables can be included in the parent frame, which can also be accessed in the function’s frame (sometimes use `nonlocal`)\n- self-reference is when a function *returns* itself, but doesn’t *call* itself\n\n### disc 03: recursion\n\n- three parts to a recursive function\n    - **base case**: the stopping condition, the simplest case, ex: $0! = 1$\n    - **recurse onto smaller problems**: to recursively call on a simpler problem than the current one and breaking it into parts\n    - **solve the big problem in parts**: since we can solve many small parts, use that to solve the bigger parts\n\n### hog\n\n- `*args` is a parameter will take a bunch of arguments and pass them all as a group\n\n### lab 04: recursion, tree recursion, python lists\n\n- if/else can be done in a list comprehension — just an ordering issue\n    ```python\n    [ [true action] if [condition] else [false action] for x in [sequence] ]\n    ```\n    \n- ternary statements in python\n    ```python\n    value_if_true if condition else value_if_false\n    ```\n    \n\n### disc 04: tree recursion, python lists\n\n- tree recursion is used for problems where there can be multiple possibilities to deal with, such as Fibonacci numbers needing to calculate `n-1` and `n-2`\n- recursive calls are made for a group of choices\n\n### disc 05: trees, data abstraction, sequences\n\n- **constructors** build abstract data type — also called constructors in Java?\n- **selectors** retrieve information from a data type — probably getters\n- tree language:\n    - **parent node**: a node that has at least one branch (child)\n    - **child node:** node with a parent\n    - **root:** the top node\n    - **label:** the value at a node\n    - **leaf:** a node with no children (branches)\n    - **depth:** how far the node is from the root\n    - **height:** the depth of the lowest leaf\n\n### disc 08: linked lists, trees\n\n- unpack a list of elements into a `zip` function by adding `*` before the list\n    - `zip(*[[1,2],[3,4],[5,6]])`\n\n### lab 10: scheme\n\n- `(or 1 #t)` evaluates to `1`\n\n### hw 07:\n\n- `(let ((bindings)) (body))`\n    - SchemeError: badly formed expression:\n        - probably missed the extra parentheses around the bindings\n\n---\n\n### unfinished/review q’s\n\n- hw01: review `quine`\n- hog: finish problem 12\n- hw02: finish `church numerals`\n- hw03: finish `towers of hanoi`; review `anonymous factorial`\n- disc04: finish `max product`\n- disc06: finish `mystery reverse environment diagram`\n- hw06 `VirFib` `is_bst`\n- disc08: `Multiply Links` `Find Paths`\n- ants: EC, optional 1 \u0026 2","lastmodified":"2022-10-14T05:23:27.484421268Z","tags":null},"/private/fa22/cs252":{"title":"CS 252","content":"\u003e The computer is not an electronic genius; on the contrary, if anything, it is an electronic idiot, doing exactly what we tell it to do. It has no mind of its own.\n\n# lectures\n## intro\n- Main components of the computer:\n\t- Processor - CPU; memory - RAM; motherboard; GPU; cooling; power supply\n\t- Storage -- SSD, HDD, thumbdrives, hard drives\n\t\t- Remembers things after the power is turned off\n\t- Output devices -- displays, sound\n\t- Input devices -- keyboard, mice, touch\n- CPU components:\n\t- Bus memory; control unit; memory (cache, register); ALU FPU; clock\n\n# reading\n## ch2: bits, data types, and operations\n-   Devices inside the computer react to the presence/absence* of voltages, rather than the actual voltage values\n    -   Presence of voltage is represented as 1, while absence is represented as 0 — these 1s and 0s are called **bits**\n    -   *Not the absolute presence/absence, but differentiate between “close to” and “far from” a target voltage, ex: if I wanted 3 volts, then 2.6 volts would signify a 1 (close to 3 volts) and 0.2 volts would signify a 0 (far from 3 volts)\n-   With $k$ bits, we can distinguish at most $2^k$ different values, by counting in binary\n-   Unsigned (and signed) integers can be represented using the **2’s complement integers**\n    -   Each digit in a binary string represents 2 to the power of that digit multiplied by 0 or 1\n        $00110 = 0\\cdot2^4+0\\cdot2^3+1\\cdot2^2+1\\cdot2^1+0\\cdot2^0=6$\n-   For signed integers, the leading value (on the left) signifies positive or negative — leading 0 is positive, leading 1 is negative\n\t- ![[Pasted image 20220911015108.png]]\n    -   $k$ bits can represent the range $[-2^{k-1}, 2^{k-1})$ where negative numbers are denoted by a leading 1\n        -   Shortcut for $-A(A\\ne0)$: flip all bits of $A$ and add 1\n    -   The carry for the leading digit is always ignored (because adding 00001 and 11111 does not make sense to produce 100000 when working with signed digits)\n- **Arithmetic and logic unit (ALU)** takes two inputs and one output to apply arithmetic\n- To convert from binary to decimal, we can multiply the $i$th bit (from the right) of the 2's complement number by $2^i$ and add a negative sign if the leading digit is 1\n- Algorithm for converting from decimal to binary:\n\t- *If $N$ is odd, the rightmost bit is 1. If $N$ is even, the rightmost bit is 0.\n\t- Subtract 1 or 0 depending on if $N$ is even or odd, and divide by 2, adding 1 or 0 depending on even/odd\n\t- Example:\n\t\t```text\n\t\t[ converting 105 to binary ]\n\t\tN = 105       : 1 (rightmost bit is 1 because N is odd)\n\t\t  = 105-1     :   (subtract 1 because N is odd)\n\t\t  = 104/2     :   (divide by 2)\n\t\tN = 52        : 01 (next bit is 0 because N is even)\n\t\t  = 52-0      :    (N is even)\n\t\t  = 52/2      :    (divide by 2)\n\t\tN = 26        : 001 (next bit is 0)\n\t\t  = (26-0)/2  : \n\t\tN = 13        : 1001 (next bit is 1)\n\t\t  = (13-1)/2  :\n\t\tN = 6         : 01001\n\t\t  = (6-0)/2   :\n\t\tN = 3         : 101001\n\t\t  = (3-1)/2   : \n\t\tN = 1         : 1101001\n\t\t```\n- Addition with bits remains the same as normal arithmetic, but subtraction is \"adding the negative number\"\n\t- Two numbers must have the same number of bits to be added\n\t- Leading 0s (or 1s for negative numbers) can be added to the front of the number to achieve equal numbers of bits -- this process is called **Sign-EXTension, or SEXT**\n- **Overflow** happens when the ALU can't represent arithmetic between two integers\n\t- Example: I want to add $01001$ (11) and $01011$ (9) but I get $10100$ which is -4 (leading 1 means negative)\n\t- Example: Adding $10100$ (-6) and $11010$ (-12) gets $01110$ which is 14\n- **Logical functions** can also be applied on binary numbers, requiring two pieces of input (either 1 or 0)\n\t- **AND:** produces 1 only if both sources have value 1, otherwise produces 0 (if both are true -\u003e true, else false)\n\t- **OR:** produces 0 only if both sources have value 0, otherwise produces 1 (if either is true -\u003e true, else false)\n\t- **NOT:** flip the bit\n\t- **XOR:** exclusive-or, produces 1 only if *one or the other* input bit is 1, but produces 0 when both inputs are 1\n\t-\n\t\t| A  | B | XOR |\n\t\t| --- | --- | --- |\n\t\t| 0 | 0 | 0 |\n\t\t| 0 | 1 | 1 |\n\t\t| 1 | 0 | 1|\n\t\t| 1 | 1 | 0|\n- **Bit vectors** can keep track of the \"status\" $n$ units where a bit is 1 if the unit is free and 0 if the unit is busy\n\t- **Bit masks** can be used to change the status of one single bit\n- Floating point data is used to represent really big or small numbers with scientific notation (ex: $6.032\\times 10^{23}$ instead of $603200000000000000000000$)\n\t- ![[Pasted image 20220911103146.png]]\n\t- 8 bits are allocated to the \"exponent\" while 23 bits are allocated to the sig figs (the 6032 in the previous example)\n\t\t- The exponent value actually represents your exponent value plus 127 (??)\n\t- Example:\n\t```text\n\tfloating point data: 00111101100000000000000000000000\n\t\t\n\t0 01111011 00000000000000000000000\n\t0 - represents positive number\n\t01111011 - equals 123, subtract 127, we get -4 as the exponent\n\t00000000000000000000000 - no fraction, so the number represented is 1\n\n\t1^(-4) = 1/16\n\t```\n- Other common data codes/notations: ASCII, hexadecimal\n\n## digital logic structures\n\n","lastmodified":"2022-10-14T05:23:27.484421268Z","tags":null},"/private/fa22/cs475":{"title":"CS 475","content":"## permutations and combinations\n- $|S|$ denotes the number of elements in $S$, cardinality/size of $S$\n- **Addition Principle:** $|S| = |S_1| + |S_2| + \\dots + |S_n|$\n\t- $S$ is partitioned such that each element within $S$ shows exactly once within any one partition, no overlapping elements\n\t- Summing all partitions should always equal $|S|$\n- **Multiplication Principle:** $|T_1\\times T_2\\times \\dots T_k|=|T_1|\\times|T_2|\\times\\dots |T_k|$\n\t- The *Cartesian product* of two sets is the set of $A \\times B$ with ordered pairs $(a, b)$ where $a$ is from $A$ and $b$ is from $B$ -- $\\{(a,b) | a\\in A, b\\in B\\}$\n- n-stage experiment describes how many subsets can be constructed from a set (?)\n- If one of your tasks \"depends\" on the choice of another task, then we can't apply the multiplication principle. Ex: if choosing the tens digit of a number *depends* on if the ones digit is odd, then we can't calculate the answer by getting the tens digit first. (describe better example)\n- **Subtraction Principle:** $|A|=|U|-|\\bar A|$\n\t- Given two sets, $A$ and $U$, where $A \\subseteq U$, the complement of $A$ in $U$ is all the elements in $U$ that are not in $A$ -- $\\bar A=U-A=\\{x|x\\in U,x\\notin A\\}$\n- **Division Principle:** $\\text{number of subsets}=\\frac{|S|}{\\text{the cardinality of each subset}}$\n\t- We partition $|S|$ into subsets of equal size and want to figure out how many *distinct* arrangements exist\n\t- \\*Divide total number of combinations by the size of each group\n- A **permutation** is an ordered arrangement of elements without repetition\n\t- An $r$-permutation is an ordered arrangement of $r$ elements where $r$ is a number\n- $n!=n(n-1)(n-2)\\cdot\\dots\\cdot(2)(1)$ where $0!=1$; product of $n$ and all integers less than $n$\n- $P(n,r)=\\frac{n!}{(n-r)!}$ for positive integers $n$ and $r$ ***REVIEW***\n\t- $P(n,r)$ represents the number of $r$-permutations of an $n$ element \n\t- Special cases: $P(n,1)=n$, $P(n,n)=n!$\n\n---\n- Main types of counting problems:\n\t- Ordered arrangements without repetition\n\t- Ordered arrangements with repetition\n\t- Unordered arrangements without repetition\n\t- Unordered arrangements with repetition\n- Nonrepetition and repetition can also be seen as items from a set (distinct members) and items from a multiset (not distinct members)\n\t- A multiset is denoted by a number before each element of the set, meaning how many of that element is present, ex: $\\{3\\cdot a, 1\\cdot b,2\\cdot c, 4\\cdot d\\}$\n- The multiplication principle cannot be applied if one outcome depends on a previous outcome -- but there may not be a fixed order that tasks need to be completed in, so try rearranging the tasks so that multiplication is applicable -- choose the most restrictive choice first\n- Arrangements where order is considered are called **permutations**, while arrangements where order is irrelevant are called **combinations**\n- $r$ is a positive integer and the number of $r$-permutation of $n$ elements can be denoted by $P(n,r)$\n\t- $S=\\{a,b,c\\}$, so $1$-permutations would be $a$, $b$, $c$; $2$-permutations would be $ab$, $ac$, $bc$, $ba$, $ca$, $cb$; etc\n\t- $P(n,r)=\\frac{n!}{(n-r)!}$\n- **Linear permutations** are permutations where objects are arranged in a line\n- **Circular permutations** arrange objects in a circle -- a permutation is only different if each element has different adjacent neighbors from previous permutations and it cannot be achieved through rotation\n\t- The number of circular permutations of $n$ elements is $(n-1)!$\n\t","lastmodified":"2022-10-14T05:23:27.484421268Z","tags":null},"/private/fa22/ece537":{"title":"ECE 537","content":"## introduction to networks\n- Internet -- network of networks\n- Computer network structure can look like this: end device (phone) -\u003e router -\u003e Internet Service Provider (ISP) -\u003e ?? -\u003e server\n\t- Router can be wifi router or a cellular provider\n\t\t- Redirects connection on where to go next ...\n\t- ISP connect determines how good router connection is (and also your phone to the router)\n- Any ~~link~~ connection between two devices can be wireless\n- **TCP/IP protocol stack:** physical \u003e link \u003e network \u003e transport \u003e application\n\t- (Transmission Control Protocol/Internet Protocol)\n\t- An *application* level protocol could look like this: client (browser tab) -\u003e ISP -\u003e backbone/hall network (?) -\u003e server\n\t\t- Nothing between client and server actually understand the information transferred -- this means applications are End-to-End protocol, only the end devices understand what's going on\n\t- Physical (layers) need *everyone* to understand the content that passes through (I think it's less private?)\n\t\u003c!-- - Transport takes one layer to another?? probably e2e protocol --\u003e\n\t- Network has protocols that define many stops/nodes (such as ISP, servers) but each stop/node only knows its own predecessor and successor, known as **routing layers**\n\t\t- Each node only cares about getting to the next node and doesn't affect other information being transferred\n\t\t- Network protocol is lower level than application/transport, so any changes on those protocols won't affect network protocol efficiency\n\t- Link layer protocol manages multiple devices talking to one service/router\n\t\t- No protocols with only link layer! always linked to physical \n\t\t- Wifi/ethernet is link and physical\n- Transport/application only need to be understood by end devices; link and physical protocol need to be understood by *all devices in the network*\n- **OSI protocol stack:** physical \u003e link \u003e network \u003e transport \u003e session \u003e presentation \u003e application (industry standard)\n\n## network architecture\n- Networks transfer chunks of information called **packets**\n\t- Data deconstruction (creating packets) is handled by the client, while data reconstruction/packet synthesizing is handled by whoever is receiving the data\n- Two main types of network systems:\n\t- **Circuit switched network:**\n\t\t- A connection of a certain mbps is dedicated to the user for the entire duration of the information transfer\n\t\t- Pros:\n\t\t\t- Connection does not delay or break because it's allocated already\n\t\t\t- You are guaranteed whatever connection speed the whole time\n\t\t\t- Less inturruption -\u003e reliable\n\t\t- Cons:\n\t\t\t- Expansion requires exponentially more resources so it's not scalable\n\t\t\t- Resource is not allocated based on need\n\t- **Packet switched network:**\n\t\t- Information is broken into packets/segments which are transferred individually and only use the connection when a transfer is in progress\n\t\t- Pros:\n\t\t\t- Network is easy to expand -- add more nodes (routers) that can accept and redirect incoming information\n\t\t\t- More people can use the same amount of resources since any downtime between a conversation can be put towards transferring someone else's data\n\t\t- Cons:\n\t\t\t- Packets can arrive out of order which cause delays\n\t\t\t- Networks can be overloaded or slow depending on usage\n- Four main types of *delays*:\n\t- **Processing delay:** \n\t\t- Time it takes to process the packet (add a header?) and find the next location to send it to\n\t\t\t- Does NOT depend on packet size -- all packets take the same time to get ready (I assume?)\n\t\t- Depends solely on the hardware and processing power of the router\n\t- **Propagation delay:**\n\t\t- Time it takes for the packet to *physically* travel through a medium (fiber optic cables, waves, wireless) to its destination\n\t\t- Depends on the distance between two nodes and the speed of the transport medium\n\t- **Transmission delay:**\n\t\t\n","lastmodified":"2022-10-14T05:23:27.484421268Z","tags":null},"/private/fa22/mse299":{"title":"","content":"","lastmodified":"2022-10-14T05:23:27.484421268Z","tags":null},"/private/fa22/physics201":{"title":"PHYSICS 201","content":"\u003c!-- # review\n\n-   The SOH-CAH-TOA trig identities only work for right triangles\n-   For finding sides and angles of general (non right) triangles:\n    -   **Law of sines**: $\\frac{\\sin{A}}{a}=\\frac{\\sin{B}}{b}=\\frac{\\sin{C}}{c}$ where the sine of an angle is divided by the length of its opposite side — should only be used if you know the angle will be acute or obtuse since it only returns values [0,90]\n    -   **Law of cosines**: $a^2 = b^2+c^2-(2bc)*\\cos{A}$\n-   The quotient rule for derivatives: $\\frac{d}{dx}(\\frac{f(x)}{g(x)})=\\frac{g(x)f'(x) - f(x)g'(x)}{(g(x))^2}$, or “low d hi _mine_ hi d low, _o_ low low”\n-   **Scalars** are values with a single number, like speed, height, temperature, while **vectors** have a magnitude and a direction, like acceleration, weight\n-   Vector operations:\n    -   Addition: $\\vec{A}+\\vec{B}=\\vec{B}+\\vec{A}=\\vec{R}$\n    -   Scalar multiplication: $s(\\vec{A}+\\vec{B})=s(\\vec{A})+s(\\vec{B})$\n-   A **unit vector** always has magnitude 1\n    -   $\\vec{v}=|\\vec{v}|\\hat{v}$ where $|\\vec{v}|$ is the magnitude of $v$ and $\\hat{v}$ is the unit vector\n    -   $x$ direction unit vector is $\\hat{i}$; $y$ direction is $\\hat{j}$; $z$ direction is $\\hat{k}$\n        -   $\\vec{V}=a\\hat{i}+b\\hat{j}+c\\hat{k}$\n-   Unit vector formula: $\\hat{u}_v=\\frac{\\vec{v}}{|\\vec{v}|}$\n    -   Magnitude formula: $|\\vec{v}|=\\sqrt{|\\vec{v}^x|^2+|\\vec{v}_y|^2+|\\vec{v}_z|^2}$\n-   **Dot product**: $\\vec{A}\\cdot\\vec{B}=|\\vec{A}||\\vec{B}|\\cos(\\theta)$; produces scalar product of two vectors\n    -   Commutative property holds; associate property only holds for scalar mult.; distributive property holds onto for vector addition\n-   **Cross product**: $\\vec{A}\\times\\vec{B}=|\\vec{A}||\\vec{B}|\\sin(\\theta)\\hat{n}$; produces vector product of two vectors\n    -   Not commutative; associative only for scalar mult.; distributive only for vector addition\n    -   Can be evaluated by taking the determinant of a 3x3 matrix\n-   The **right hand rule** is used to determine the direction of the norm vector $\\hat{n}$ of a cross product\n\n![right hand rule](/images/physics201/right-hand-rule.png)\n\n-   A **position vector** describes the location of a particle relative to a reference point at time $t$\n-   A **displacement vector** is the change in the position of a particle between two distinct time periods\n-   **Average velocity** is the change in displacement divided by the change in time $\\vec{v}_{avg}=\\frac{\\Delta\\vec{r}}{\\Delta t}$ while the **velocity vector** is the velocity of a particle at a moment in time $\\vec{v}(t)=\\frac{d\\vec{r}(t)}{dt}$\n    -   The speed (scalar) of the particle is the magnitude of the velocity at that moment\n-   The **acceleration vector** is the second derivative of the position vector $\\vec{a}(t)=\\frac{d\\vec{v}(t)}{dt}$\n-   Constant acceleration can be assumed for most many scenarios (like projectile motion) and the following three equations can be used:\n    -   $v=v_0+a_c(t-t_0)$\n    -   $s = s_0+v_0(t-t_0)+\\frac{1}{2}a_c(t-t_0)^2$\n    -   $v^2=v_0^2+2a_c(s-s_0)$\n-   **Projectile motion** is the motion of a particle moving through the air, while **free fall** is straight line motion with zero initial velocity\n-   Horizontal and vertical motion are independent of each other\n-   Equations relating components of a vector:\n    -   $v^2 = v_x^2+v_y^2$\n    -   $v_{0x}=v_x\\cos\\theta$; $v_{y0}=v_0\\sin\\theta$\n-   **Newton’s Laws of Motion**\n    -   **First**: A body remains at rest or remains in motion in the absence of applied forces — if there is zero net force, then object remains in constant velocity\n    -   **Second**: $\\vec{F}=m\\vec{a}$\n    -   **Third**: The forces of action and reaction between particles are equal in magnitude, opposite in direction, and collinear\n-   **Normal force** is the force which prevents an object from moving through a surface (like a floor)\n-   **Friction** is the portion of contact force between two surfaces, tangent to the contact surface — it is always opposing relative motion between contacting objects\n    -   $F=$ friction force; $\\mu_s=$ static coefficient of friction; $N=$ normal force; $\\mu_k =$ kinetic coefficient of friction\n    -   No slip: $|F|\u003c\\mu_s|N|$ — the objects are not moving or sliding against each other; friction cannot be calculated based on $\\mu$ and $N$, but could be calculated from $\\vec{F}=m\\vec{a}$\n    -   Impending slip: $|F|=\\mu_s|N|$ — one object is just about to slide against the other\n    -   Slip: $|F|=\\mu_k|N|$ — they are sliding\n\n--- --\u003e\n\n# lectures\n## course intro \u0026 measurement\n- The final figure is the \"estimated\" figure -- keep all sure digits and one estimated digit\n- Don't count leading zeroes when counting sig figs, but include tailing zeroes\n- Keep all digits until calculations are finished and round after\n\t- Addition/subtraction: the last significant figure after the decimal point can't be more accurate than any of the operands, meaning the # of sig figs (after decimal) is the same as the lowest out of the operands\n\t- Multiplication/division: lowest # of sigfigs among all operands, note that it's NUMBER of sigfigs which is different than after the decimal point\n\n# reading\n## ch1: physics and measurement\n- **SI** system of measurement:\n\t- **Length (meters)** as the distance between two points\n\t- **Mass (kilograms)** as an object's amount of material...\n\t- **Time (seconds)**\n- **Density ($\\rho$):** $\\rho\\equiv\\frac{m}{V}$; mass per unit volume\n- Sometimes we want to express really small numbers, which we can do so using scientific notation and *order of magnitude*, where the ~ symbol denotes \"is on the order of\", ex: 720m ~ (is about) 10^3m\n\n## ch2: motion in one dimension\n-   **Position ($x$):** location of the particle with respect to an origin point\n-   **Displacement ($\\Delta x)$:** $\\Delta x\\equiv x_f-x_i$; change in _position_ over a time interval\n    -   **Average velocity (m/s):** $v_{x,avg}\\equiv\\frac{\\Delta x}{\\Delta t}$; _displacement_ per time interval\n    -   **Instantaneous velocity (m/s): $v_x\\equiv\\frac{dx}{dt}$**; _velocity_ at a moment in time\n-   **Distance:** length of a path travelled by a particle — different than _displacement_\n    -   Displacement can be zero even if distance is not zero, ex: moving down a hallway and then returning to the starting position has a displacement of 0, but a distance of the length of the hallway travelled * 2\n    -   **Average speed (m/s):** $v_{avg}\\equiv\\frac{d}{\\Delta t}$; _distance_ per time interval\n    -   **Instantaneous speed (m/s):** magnitude of _instantaneous velocity_\n-   **Vector:** direction and magnitude; **Scalar:** numerical value and no direction\n-   A particle can have a constant velocity, which implies that it has a constant speed; however, constant speed does not imply constant velocity (magnitude can stay the same, but direction doesn’t always)\n-   Problem solving approach: conceptualize, categorize/simplify, analyze, finalize\n- **Average acceleration ($a_{x,avg}=\\frac{\\Delta v_x}{\\Delta t}$):** measured in $\\frac{m}{s^2}$ and describes the change in velocity over time\n\t- **Instantaneous acceleration ($a_x=\\frac{dv_x}{dt}=\\frac{d^2x}{dt^2}$):**\n\t- Kinematics equations assumed to be true under constant acceleration:\n\t\t- $v_{xf}=v_{xi}+a_xt$\n\t\t- $x_f=x_i+\\frac{1}{2}(v_{xi}+v_{xf})t$\n\t\t- $x_f=x_i+v_{xi}t+\\frac{1}{2}a_xt^2$\n\t\t- $v_{xf}^2=v_{xi}^2+2a_x(x_f-x_i)$\n- If acceleration and velocity have the same sign, that means the particle is speeding up; if they have different signs, the particle is slowing down\n- A freely falling object is any object moving solely under the influence of gravity\n\t- Acceleration due to gravity, or **free-fall acceleration**, is denoted with $g$, and is about $9.8 \\frac{m}{s^2}$\n\n## ch3: vectors\n- Cartesian coordinates, also called rectangular coordinates, are expressed as $(x, y)$\n- Polar coordinates are measured in distance from the origin, and angle from the positive right axis -- $(r, \\theta)$\n- **Scalars** consist of a single value with a unit but without a direction; **vectors** have number, unit (magnitude), and direction\n\t- Vectors are comprised of *components*, which are the $x$ and $y$ vectors that make up the vector -- $A_x=A\\cos\\theta$, $A_y=A\\sin\\theta$\n- A **unit vector** is a dimensionless vector that has a magnitude of 1 -- it only specifies 1 unit of distance in a direction\n\t- Common unit vectors include $\\hat{i}$, $\\hat{j}$, $\\hat{k}$ for one unit in the $x$, $y$, and $z$ directions respectively\n\t- Vectors can be added by adding their components together\n- Vectors can be added by using the head-to-tail method of placing the tail of a new vector at the tip of the last vector\n- ![[Pasted image 20220911112820.png]]\n\t- Addition is commutative and associative\n\t- Subtraction is adding a negative vector -- invert both the direction and magnitude of a vector to get its negative version\n- Scalar multiplication for vectors consists of multiplying the magnitude by a scalar value\n\n## ch4: motion in two dimensions\n- **Position vector ($\\vec{r}$):** $\\vec{r}=x\\vec{i}+y\\vec{j}$;  location of the particle with respect to the origin of a coordinate system\n- **Displacement vector ($\\Delta \\vec{r}$):** $\\Delta \\vec{r}\\equiv\\vec{r}_f-\\vec{r}_i$; a vector that describes the change in position vectors\n\t- **Average velocity:** $\\vec{v}_{avg}\\equiv\\frac{\\Delta\\vec{r}}{\\Delta t}$; displacement vector per time interval, or how much the displacement changes for every $t$ -- results in a vector along $\\Delta\\vec{r}$\n\t- **Instantaneous velocity:** $\\vec{v}\\equiv\\frac{d\\vec{r}}{dt}$; velocity vector at a moment in time, tangent to the particle's path\n\t\t- Speed ($|\\vec{v}|$) of the particle is the magnitude of the *instantaneous velocity*\n- **Average acceleration ($\\vec{a}_{avg}\\equiv\\frac{\\Delta\\vec{v}}{\\Delta t}$)** and **instantaneous acceleration ($\\vec{a}\\equiv\\frac{d\\vec{v}}{dt}$)** describe the change in velocity per $t$ and as $t$ approaches 0 respectively\n\t- Under constant accerlation, we can assume the following equations: (Search \"four kinematics equations\")\n\t\t- $\\vec{v}_f=\\vec{v}_i+\\vec{a}t$\n\t\t- $\\vec{r}_f=\\vec{r}_i+\\vec{v}_it+\\frac{1}{2}\\vec{a}t^2$\n\t\t- $\\vec{r}_f=\\vec{r}_i+\\frac{1}{2}(\\vec{v}_i+\\vec{v}_f)t$\n\t\t- $\\vec{v}_f^2=\\vec{v}_i^2-2\\vec{a}\\Delta\\vec{r}$\n\t\t![constant acceleration equations](/images/physics201/constant-acceleration-eqns.png)\n - Movement in the $x$ direction does not affect movement in the $y$ direction -- motion in 2d can be modelled as two independent motions\n - **Projectile motion** is parabolic motion through the air where we assume free-fall acceleration is constant and air resistance is negligible\n - One specific case of projectile motion is when it returns to the same horizontal level as when it starts\n![projectile motion](/images/physics201/projectile-motion.png)\n\t - $h$ is the maximum height ($h=\\frac{v_i^2\\sin^2\\theta_i}{2g}$), while $R$ is the horizontal range of the particle ($R=\\frac{v_i^2\\sin2\\theta_i}{g}$)\n\t\t - $R$ is at its maximum when $\\theta$ is 45 degrees\n\t\t ![different ranges at various angles](/images/physics201/angle-example.png)\n- Uniform circular motion describes when a particle is moving in a circular motion at a constant speed\n\t- The direction of the velocity vector is always changing in circular motion, so an acceleration is present and points towards the center of the circle, perpendicular to the velocity vector\n- Acceleration in circular movement is defined by $a_c=\\frac{v^2}{r}$, $a_c=r\\omega^2$, also called **centripetal acceleration**\n\t- The length of time it takes to complete one circle of rotation is called the **period** $T$ -- $T=\\frac{2\\pi r}{v}$\n\t- **Angular speed** $\\omega$ is measured in radians/second and is the inverse of $T$ -- $\\omega=\\frac{2\\pi}{T}$\n\t- $v=r\\omega$: as radial position increases (away from the center), speed also increases","lastmodified":"2022-10-14T05:23:27.484421268Z","tags":null},"/stream":{"title":"Stream","content":"This serves as a hub for all of my recent edits on my website. All of my writing is organized into three categories — **seed** (🌰) for quick thoughts, **leaf** (🌿) for revised ideas, and **fruit** (🥭) for completed blog posts.\n\n- ✏️ 22-08-27 `::` [CS 61A: Structure and Interpretation of Computer Programs](https://emilyyao.me/notes/cs61a)  \n- ✏️ 22-08-27 `::` [6.042J: Mathematics for Computer Science](https://emilyyao.me/notes/6-042j)  \n- 🥭 22-07-16 `::` [Summer Exploration Arc #3](https://emilyyao.me/2022-sea3)\n- ✏️ 22-07-14 `::` [CS 220: Data Programming I](https://emilyyao.me/notes/cs220)\n- 🌰 22-07-08 `::` [Installing Ubuntu 22.04 on macOS Monterey using UTM](https://emilyyao.me/utm-ubuntu)\n- 🥭 22-06-26 `::` [Summer Exploration Arc #2](https://emilyyao.me/2022-sea2)\n- 🥭 22-06-11 `::` [Summer Exploration Arc #1](https://emilyyao.me/2022-sea1)","lastmodified":"2022-10-14T05:23:27.488421331Z","tags":null},"/utm-ubuntu":{"title":"Ubuntu 22.04 with UTM","content":"- No easy way to dual boot with the M1 chips -- UTM is a software specifically for macOS to run VMs or emulate other machines\n- How to create a new Ubuntu VM:\n    - Install the 22.04 live server arm64 ISO image\n    - Start \u003e Virtualize \u003e Other and select the ISO image\n    - Create a new NVMe drive for 20GB\n    - Go through Ubuntu setup\n- Installing GNOME desktop environment\n    - `sudo apt update \u0026\u0026 sudo apt upgrade`\n    - `sudo apt install ubuntu-gnome-desktop`\n    - `reboot`\n\nArticles that I used:\n- https://bytexd.com/how-to-install-gnome-desktop-in-ubuntu/\n- the beginning of this video https://youtu.be/GjqeoC267FM\n- the middle of this video https://youtu.be/hnwK-nkXolc","lastmodified":"2022-10-14T05:23:27.488421331Z","tags":null}}