{"/":{"title":"emilyyao.me","content":"\n# hey, it's squeak!\nWelcome to my pothole of the internet. I'm Emily! My nickname is \"*squeak*\" ‚Äî from which most of my usernames on the web are derived. I'm currently a first-year at UW-Madison interested in *robotics, machine learning, and internet privacy*. In my free time, I love reading historical fiction and listening to [copyrighted Nintendo music](https://youtu.be/HL9_xm5HwrE).\n\nIf you're looking for my notes, check out [wiki.emilyyao.me](https://wiki.emilyyao.me/)!\n\n# relevant\n- Check out my growing portfolio on [GitHub](https://github.com/heyitssqueak).\n- ~~Get ignored by~~ Add me on [LinkedIn](https://www.linkedin.com/in/emilyyao04/).\n- Say hello! `hello [at] emilyyao.me`\n\n# recent\nCheck out the [stream](/stream.md)!\n- üåø ongoing `::` [notes](/notes/6.042j.md) from 6.042J\n- üåø ongoing `::` [notes](/notes/cs220.md) from CS 220\n- ü•≠ 22-06-26 `::` [SEA progress update](/2022-sea2.md) `(sea#2)`\n- ü•≠ 22-06-11 `::` [the beginning](/2022-sea1.md) of my summer learning quest `(sea#1)`\n\n\u003c!-- Here are some notable links for you to guide your way:\n- [Anything and everything](/stream) I write about, seperated into [academics](/academics), [worldbuilding](https://dream.emilyyao.me), and [blog posts](/writing)\n\n- The [Portfolio](/portfolio) and the [Anti-Portfolio](/anti-portfolio) --\u003e\n\n\u003c!-- - My ongoing [[projects]]! --\u003e\n\n\u003c!-- I enjoy meeting as many people as I can! If you want to recommend me a book or ask about my website, send me a chat through [Element](https://element.io) at `@squeakers:matrix.org`. --\u003e\n\n\u003c!-- # recent  \nFor more information on the emojis (üå∞, üåø, ü•≠), check [this](/stream) out.\n- üåø 22-05-06 `::` [a few ramblings](/writing/slaughterhouse-five) about Kurt Vonnegut's *Slaughterhouse-Five* --\u003e\n\n\n\u003c!-- # WIP\n- set up worldbuilding @ dream.emilyyao.me\n- set up academic stuff @ wiki.emilyyao.me\n    - alter cactus theme to have graph\n    - test with lin alg notes\n- write a blog post about something ie make the website presentable with Content --\u003e","lastmodified":"2022-07-06T21:15:13.452172199Z","tags":null},"/2022-sea1":{"title":"Summer Exploration Arc #1","content":"## motivation\nI've always wanted to document my growth over a period of time to see what I can accomplish on my own. This summer is an ideal place to start -- just after high school and before college, where I have enough agency to achieve my goals, without too much academic stress. I'm drawing motivation from this saying: \n\n\u003e Most people overestimate what they can do in a day, but underestimate what they can do in a year.\n\nMy goals are the following:\n- Learn about topics that I think I would enjoy\n- Work on some small projects\n- Build healthy habits\n- Read more, write more\n- Enjoy that summer sun\n\nThey are vague on purpose -- I'll have plenty of options that accomplish these tasks without feeling restricted to a particular path.\n\n## starting point\n### online classes\nBefore the fall semester starts, I want to do a bit of learning on my own. For the most part, I'm going to be reviewing old classes (linear algebra, data structures / algorithms) and exploring new classes (discrete math, artificial intelligence, signals and systems). This is for me to \"test the waters\" and try out things that are interesting to me.\n\n### cool projects\nI'm interested in making something for 3Blue1Brown's [Summer of Math Exposition #2 (SoME2)](https://youtu.be/hZuYICAEN9Y). I'm not particularly sure what knowledge I have to offer but I'm planning on something within the computer science or signal processing realm. \n\nI've also been interested in cybersecurity for the past few months, but never got around to actually learning more about it. Since I have more time now, I want to take advantage of some resources like [HackTheBox](https://hackthebox.com), [OverTheWire: Wargames](https://overthewire.org/wargames/), the [DEF CON CTF archive](https://archive.ooo/) to help me learn more. At the beginning of this year, my goal was to participate in the DEF CON 30 CTF qualifiers, but that has since passed -- my new goal is to take a shot at next year's qualifiers, but we'll see about that...\n\nAmong other things, I want to clean up my website better and get my wiki space set up.\n\n## plan\nMy next update will be in two weeks. For the most part, I want to see where things will take me, so I don't really have a concrete schedule.","lastmodified":"2022-07-06T21:15:13.452172199Z","tags":null},"/2022-sea2":{"title":"Summer Exploration Arc #2","content":"## recap\nI made a [post](/2022-sea1.md) two weeks ago where I wrote about what I wanted to accomplish in my free time this summer. This is my first progress update.\n\nMy focus has primarily been on settling into a good routine where I can balance work and learning in my downtime. I teach summer camps in the morning which has helped me build a solid morning routine. I have plenty of free time in the afternoons, which I've been trying to put towards doing something useful.\n\n## progress\n### academics\nHistorically, I don't have a good track record when it comes to self-paced online courses -- I struggle a lot with finding an interesting yet not-too-difficult class. So far I've tried and dropped Caltech's [Learning From Data](https://work.caltech.edu/telecourse) course because I didn't understand how to do the homeworks -- the answers were in Python, and I don't know Python. I also gave MIT's [18.06SC: Linear Algebra](https://openlearninglibrary.mit.edu/courses/course-v1:OCW+18.06SC+2T2019/about) a shot, but it's moving along very slowly. I think my hesitancy with this class comes from how I'm not confident at writing proofs. While I enjoy Gilbert Strang's lectures, I blank when it comes to applying new concepts on my own.\n\nGoing back to how I don't know Python: it's been on my todo list for a long time. I never got around to actually *learning* Python, and most of my prior experience came from doing beginner [Advent of Code](https://adventofcode.com/) problems. I did find a course that I've been working through [(CS 220 from UW-Madison)](http://msyamkumar.com/cs220/s20/schedule.html) and I'm about 1/3 of the way through. This has been my main focus for the past week as I've settled into this whole summer exploration thing.\n\n### cybersecurity\nLast week I managed to set up Kali Linux on my laptop after a bit of fiddling around. I'm not sure what I intend to do with it -- so far I've just been trying out the [Linux Fundamentals](https://academy.hackthebox.com/course/preview/linux-fundamentals) course on [HTB Academy](https://academy.hackthebox.com/). I want to get more familiar with using terminal and other command line tools. I also plan to finish a cybersecurity certificate I started a long time ago.\n\n### website\nAfter my last post, I spent a while working on my wiki website which is live now at [wiki.emilyyao.me](https://wiki.emilyyao.me). There are still a few things I need to work out (such as the side TOC being wonky on mobile) but it's a good start. I want to use somehow organize my notes and ramblings into comprehensive pages soon. This project will probably take a while until it is presentable. My main goal is to consistently update this during the school year and create something that can help other people, too.\n\n### \"Enjoy that summer sun\"\nI am sunburnt\n\n### misc\n- [my Taiko addiction](https://youtu.be/QbPj5vfprIQ)\n- Current reads: *Homegoing* by Yaa Gyasi; *Normal People* by Sally Rooney\n\n## plan\nMy first goal is to finish the CS 220 course which might take a bit longer than two weeks. I'd also like to finish both of the books I'm currently reading. Other side goals include: finishing the Linux course with HTB, cleaning up my old calculus notes on my wiki, and exiting my house to do something other than drive to work.","lastmodified":"2022-07-06T21:15:13.452172199Z","tags":null},"/academics":{"title":"Notes","content":"This branch (`emilyyao.me/notes/`) is used for freehand/spontaneous notes that I take in class. Other content can be found [here](https://wiki.emilyyao.me).\n\n## ongoing\n- [6.042J: Mathematics for Computer Science](/notes/6.042j.md)\n- [CS 220: Data Programming I](/notes/cs220.md)\n\n\u003c!-- ## past\n- [Linear Algebra](/academics/linear-algebra)\n- [Multivariable Calculus](/academics/multivar-calc) --\u003e\n","lastmodified":"2022-07-06T21:15:13.452172199Z","tags":null},"/notes/6.042j":{"title":"6.042J: Mathematics for Computer Science","content":"\n# proofs\n\n## introduction to proofs\n\n- a **proposition** is a statement that is either true or false\n- the $::=$ means ‚Äúequal by definition‚Äù and usually just $=$ is used\n- you can‚Äôt check a claim about an infinite set by checking a finite set of elements\n- symbols\n    - $\\forall$ for all\n    - $\\mathbb{N}$ nonnegative integers\n    - $\\in$ is in, is a member of, belongs to\n    - $\\mathbb{Z}^+$ positive integers\n\n**Proposition.** $313(x^3+y^3)=z^3$ has no solution when $x$, $y$, $z \\in\\mathbb{Z}^+$.\n\nThis latter part can be read as ‚Äúwhen $x$, $y$, $z$ are in the set of all positive integers‚Äù or simpler, there is no solution when $x$, $y$, $z$ are all positive. This proposition is false (but the counterexample has more than 1000 digits.)\n\n- a **predicate** is a proposition whose truth depends on variables and is denoted by [a letter with a function-like notation], ex: ‚Äú$n$ is a perfect square‚Äù depends on the value of the variable $n$\n    - $P(n)::=$ ‚Äú$n$ is the perfect square‚Äù, where we can say $P(4)$ is true and $P(5)$ is false, then $P(n)$ is either true or false.\n- **axioms** are propositions that are simply accepted as true\n- a **proof** is a sequence of logical deductions using axioms and other proved statements\n- other terms for propositions\n    - **theorems** are *important* true propositions\n    - **lemmas** are preliminary propositions useful for proving later propositions\n    - **corollaries** are propositions that [follow in a few logical steps from a theorem] ‚Äî *correlating* to a theorem\n- logical deductions are used to prove new propositions using previously proved propositions","lastmodified":"2022-07-06T21:15:13.452172199Z","tags":null},"/notes/cs220":{"title":"CS 220: Data Programming I","content":"Self-paced course taken summer '22, linked [here](https://www.msyamkumar.com/cs220/s20/syllabus.html). Introductory data science programming using Python, focusing on analyzing data quickly and efficiently. Texts used include Allen B. Downey's *Think Python, 2nd Edition* and Al Sweigart's *Automate the Boring Stuff*.\n\n# control flow\n\n## introduction\n- inputs: keyboard, mouse\n- outputs: monitor, speaker\n- devices attach to the computer via ‚Äúports‚Äù (USB)\n- motherboard: main circuit and connects to other components with sockets and slots\n- CPU, central processing unit\n    - runs code (receives input, sends output)\n    - runs on a clock, measured in Hz (ex. GHz is billions of ticks per second)\n    - high speed CPU ‚Üí hotter\n    - computers have multiple CPUs\n- RAM, random access memory\n    - short term data storage\n        - CPU sends to and from RAM\n    - ‚Äúvolatile‚Äù - lose data when computer is powered off\n    - one byte = one letter\n- storage drives\n    - HDD, hard disk drive\n        - inexpensive, moving parts, slow\n    - SSD, solid state drive\n        - expensive, no moving parts, fast\n    - stores data after computer shut down\n- network: an extension or built-in card to the motherboard\n    - NIC, network interface controller\n        - provides communication to other machines + internet\n    - wired = ethernet, wireless = wifi\n    - server: computer waits for incoming requests which it responds to\n    - client: program that sends requests to a server\n- jupyter notebook runs and displays results of py code without needing to run it yourself\n\n---\n\n## the terminal\n\n- you can connect to terminals located anywhere, such as connecting to a remote computer OR connecting to a personal computer\n- shell helps navigate to program and run\n- helpful shell commands    \n    - `pwd` get working directory ‚Üí current location\n    - `man` opens manual pages for command\n    - `\u003ctab\u003e` autocomplete\n    - `\u003cctrl-C\u003e` kill / exit\n    - `\u003cup arrow\u003e` last used command\n    - `\u003cctrl-R\u003e` search used commands\n    - `cd` open directory\n        - `cd ..` go up a directory\n        - `cd /` go to top directory\n    - `ls` lists contents of current directory\n    - `mkdir` makes new directory\n    - `echo` repeat or copy\n    - `cat` display contents of file\n    - `mv [original] [destination]` move files\n    - `cp [original] [destination]` copy files        \n- pathname: the location of your file (windows: includes drive letter, filename, extension‚Ä¶)\n    - absolute: always possible (complete path name to file)\n    - relative: with respect to current location\n    - working directory: current location\n    - `..` navigates up a directory\n    - `.` navigates into a directory\n- arguments are inputs that come after the call of the program name\n- use `\u003e` to redirect output to a new file\n- use `\u003e\u003e` to add output to a file\n\n---\n\n## programming\n\n- interpreter: a program that translates human-legible code into machine-legible code\n- editor: a program where you can write code\n- jupyter notebook mixes code with other things like images, tables, documentation, etc\n- ways to run python\n    - `python` interactive, denoted by `\u003e\u003e\u003e`\n    - `python [program name]` script\n    - `jupyter notebook` notebook\n- python uses order of operations to simplify equations (parentheses, exponents, m/d, a/s)\n    - negative and positive signs take precedence over m/d\n    - logic operators come after comparison operators which come after math operators\n\n![diagram](/images/operator-precedence.png)\n\n- boolean operators\n    - AND: true when both conditions are true (t/t), false otherwise (t/f, f/t, f/f)\n    - OR: true when one condition is true (t/t, t/f, f/t), false otherwise (f/f)\n    - NOT: true when the condition is false\n        - evaluate: NOT(is it saturday?)\n            - if (is it saturday?) is true, then the expression is false, i.e., it IS saturday\n            - if (is it saturday?) is false, then the expression is true, i.e., it is NOT saturday\n\n### downey ch1: the way of the program\n\n- python uses symbols as *bitwise* operators and words as logic operators\n    - `and` `or` are logic operators\n    - `\u0026` `|` are bitwise operators\n        - convert arguments into binary before comparisons\n- common types: int, float, string, boolean\n- parsing is understanding structure and meaning in a language\n    - formal language: specifically designed languages (like mathematical or molecular notation); means exactly what it says, unambiguous, less redundant/more concise\n    - natural language: naturally-evolved language (like English); has idioms/metaphor, needs redundancy to make up for ambiguity\n\n---\n\n## variables and expressions\n\n- expressions are a mix of operators (logic, mathematical) and operands (values)\n    - an operand *could* be a variable which means it won‚Äôt be a fixed value\n    - `//` is the floor division operator: `x // y` is ‚Äúhow many times does `y` go into `x`?\n- assignments compute an expression and put the result in a variable ‚Äî assignment operator is `=`\n    - ex: `total = x+y` where `total` is the resultant variable; `x` and `y` are operands (and also variables); `x+y` is the expression\n- types of errors\n    - syntax error: the written code is wrong, Python won‚Äôt run, ex: `5 = x`, we can‚Äôt assign `x` to the number `5`\n    - runtime errors: something that crashes when we run the code, ex: `x = 5 / 0`, can‚Äôt divide by zero and will result in a `ZeroDivisionError`\n    - semantic (logic) error: the code runs but you don‚Äôt get the result you want\n- python variable naming conventions\n    - don‚Äôt use keywords\n        |     |     |     |     |     |     |     | \n        | --- | --- | --- | --- | --- | --- | --- |\n        | False | assert | del | for | in | or | while |\n        | None | break | elif | from | is | pass | with |\n        | True | class | else | global | lambda | raise | yield |\n        | and | continue | except | if | nonlocal | return |  |\n        | as | def | finally | import | not | try |  |\n    - don‚Äôt name your variable after a type, like `int` or `str`\n    - only use letters (upper + lower), numbers, underscores\n        - don‚Äôt start the variable name with a number\n    \n    | examples | nonexamples |\n    | --- | --- |\n    | CS220 | 220class |\n    | cs_220 | x! |\n    | _cs220 | pi3.14 |\n\n### downey ch2: variables, expressions and statements\n\n- python conventionally uses lowercase and underscores for variable names\n    - illegal names will cause syntax errors\n- python code can be saved into files called *scripts* which end with `.py`\n- `print()` needs to be used in script mode if you want to display outputs\n- PEMDAS is helpful for remembering the order of operation for expressions\n    - **P**arentheses, **E**xponents, **M**ultiplication and **D**ivision, **A**ddition and **S**ubtraction\n- can‚Äôt perform mathematical operations on strings but we *can* add strings together (called string concatenation)\n    ```python\n    first = 'throat'\n    second = 'warbler'\n    print(first + second)\n    \u003e throatwarbler\n    ```\n- strings can also be multiplied, ex: `'Spam'*3` is `'SpamSpamSpam'`\n- comments are lines that the computer will ignore ‚Äî used to make notes between lines of code for humans to read\n    ```python\n    # compute percentage of an hour\n    percentage = (minute * 100) / 60\n    ```\n    - everything on the line with the `#` symbol is ignored\n    - usually used to denote things that aren‚Äôt obvious to the reader ‚Äî meanings of variables, functions\n- syntax errors appear *before* the program is run; runtime errors appear *after* the program has run; semantic errors don‚Äôt appear at all\n\n---\n\n## using functions\n\n- functions are ‚Äúmini-programs‚Äù or small steps that can build a big program\n- refactoring is when the code is reorganized\n- **parameters** are variables that receive a function‚Äôs input\n- **arguments** are values that are sent to a function\n    - default arguments are values that are sent to the function *if* no custom value is provided\n- **return values** are outputs from the function\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/67c58043-cd64-44c3-8674-953c2dd46f0b/Untitled.png)\n\n- calling a function in python: `[fnc name]([arguments])` ex: `print(\"hello\")` where `print` is the function name, followed by parentheses, and `\"hello\"` is the argument\n\n### downey ch3: functions\n\n- **function** - a named sequence that performs a computation\n- python has *modules* which are prewritten code that you can use in your program by importing\n    - ex: functions from the math module can be used after importing it with `import math`, including `math.sin()`, `math.log10(), etc`\n- functions can be called using *dot notation* which is the format `[module name].[function name]`\n- variables are always on the left side of an assignment operator\n\n---\n\n## creating functions\n\n- math to python example\n    $f(x)=x^2$\n    `def f(x):\n        return x ** 2`\n    - both functions are called `f` and take a parameter, `x`, and return the value of `x` squared\n- indentation is important in python!\n    - following the colon after the first line of a function, all following lines are indented 4 spaces\n- filling parameters\n    - positional arguments ‚Äî arguments assigned by position\n        ```python\n        def foo(x, y = -1):\n            x = [] # this would be 99, because 99 is the first arg\n    \t    y = [] # this would be 100\n\n        foo(99, 100)\n        ```\n    - keyword arguments ‚Äî arguments assigned to variable names\n        ```python\n        def foo(x, y = -1):\n            x = [] # this would be 100 because we said x=100 below\n            y = [] # this would be 99\n        \n        foo(y=99, x=100)\n        ```\n    - default arguments ‚Äî inserted arguments if nothing is provided\n        ```python\n        def foo(x, y = -1):\n            x = [] # this would be 99 \n            y = [] # this would be -1 because we specified it above\n        \n        foo(99)\n        ```\n- `return` will provide code to the program that can be used later, while `print()` will output the code to a terminal\n\n### downey ch3 (cont.): functions\n\n- custom functions can be added by using the keyword `def`\n    - the **header** of the function is the first line, while the **body** **(indented 4 spaces) is the rest of the function\n- if the parentheses after the function name are empty, that means the function doesn‚Äôt take any arguments\n    ```python\n    def foo():\n        print(36)\n    \n    foo()\n    \u003e 36\n    ```\n- functions have to be created before they can be called ‚Üí function definitions are always at the top of a program\n    - execution begins at the top of the program and moves down\n- *fruitful functions* return values; *void functions* don‚Äôt return anything\n    - usually want to perform an action with the output of a fruitful function\n\n### reading: creating fruitful functions\n\n- to send a value to a variable instead of printing it to a screen, we can use the `return` keyword ‚Üí is called a fruitful function\n    - result is stored in a variable and can be used again\n    ```python\n    # using print\n    def get_name(first, last):\n        print(first + \" \" + last)\n    \n    name = get_name(\"Jane\", \"Doe\")\n    \u003e \"Jane Doe\"\n    \n    print(name)\n    \u003e None # nothing is assigned to 'name' so it has the None type\n    ```  \n    $\\phantom{-}$\n    ```python\n    # using return\n    def get_name(first, last):\n        return(first + \" \" + last)\n    \n    name = get_name(\"Jane\", \"Doe\") # nothing prints because there is no print statement\n    \n    print(name)\n    \u003e \"Jane Doe\" # the name is returned through the function\n    ```\n- once a `return` statement is reached, the function ends\n    ```python\n    # using print()\n    def countdown_print():\n        print(3)\n        print(2)\n        print(1)\n    \n    countdown_print()\n    \u003e 3\n    \u003e 2\n    \u003e 1\n    ```\n    $\\phantom{-}$\n    ```python\n    # using return\n    def countdown_return():\n        return 3\n        return 2\n        return 1\n    \n    countdown_return()\n    \u003e 3\n    ```\n- `__builtins__` is a special module that is already imported\n- `dir()` lists all functions that are part of a module\n- `.__doc__` returns the documentation of a function\n    ```python\n    import math\n\n    print(math.log.__doc__) # [module name].[function name].__doc__\n    \u003e log(x, [base=math.e])\n    \u003e Return the logarithm of x to the given value\n    ```\n\n---\n\n## function scope\n\n- variable names can be organized in *frames*\n- **frames** are created when a function is called ‚Äî parameters and variables exist in the frame (also called scope?)\n    ```python\n    def print_twice(s): # function frame\n        print(s)\n        print(s)\n    \n    def cat_twice(p1, p2): # different function frame\n        cat = p1 + p2\n        print_twice(cat)\n    \n    line1 = \"bing bong\" # lies in the global frame\n    line2 = \"bong bing\" # lies in the global frame\n    cat_twice(line1, line2)\n    ```\n    - the module can access two variables: `line1` and `line2`\n    - `cat_twice()` accesses three variables: `p1` (which is `line1` passed through the function), `p2` (which is `line2` passed through the function), and `cat`\n    - `print_twice()` only accesses one variable: `s` which is `cat` passed through\n- local variables\n    - functions don‚Äôt execute unless they‚Äôre called\n        ```python\n        def set_x():\n            x = 100\n        \n        print(x)\n        # doesn't print anything because set_x() wasn't called\n        ```\n    - variables created in a function die after the function returns\n        ```python\n        def set_x():\n            x = 100\n        \n        set_x()\n        print(x)\n        # doesn't print because x doesn't exist after the end of the function\n        ```\n    - variables are reset every time a function is called\n    - variables aren‚Äôt shared across functions\n        ```python\n        def display():\n            print(x)\n        \n        def main():\n            x = 100\n            display()\n        \n        main()\n        ```\n        - even though `x` is set to be `100` in the `main()` function, the `display()` function can‚Äôt see the `x` value and it doesn‚Äôt print anything\n- global variables can be used inside functions\n    - python assumes any variables assigned within functions are *local variables*\n        ```python\n        msg = \"hello\"\n        \n        def greeting():\n            msg = \"welcome!\" # local variable, only present within the function\n            print(\"greeting: \" + msg)\n        \n        print(\"before: \" + msg) \n        greeting()\n        print(\"after: \" + msg)\n        \n        \u003e before: hello\n        \u003e greeting: welcome!\n        \u003e after: hello\n        ```\n- use `global [var name]` to declare when to create a global variable\n    ```python\n    msg = \"hello\"\n    \n    def greeting():\n        global msgd\n        msg = \"welcome!\" # local variable, only present within the function\n        print(\"greeting: \" + msg)\n    \n    print(\"before: \" + msg) \n    greeting()\n    print(\"after: \" + msg)\n    \n    \u003e before: hello\n    \u003e greeting: welcome!\n    \u003e after: welcome!\n    ```\n- python arguments are ‚Äúpassed by value‚Äù meaning any change to an argument that happens inside a function does *not* apply to that variable outside of the function\n- the argument and parameter can have the same (or different) name\n\n### downey ch3 (cont.): functions\n\n- inside a function, arguments are assigned to variables called *parameters*\n- variables created inside functions exist only in that function\n- a **traceback** is a list of functions that details what file, line, and functions caused an error\n- usefulness of functions\n    - repetitive code can be named and grouped, which makes debugging easier\n    - reusuable\n- Linux started out as a program that would switch between printing `AAAA` and `BBBB`\n\n---\n\n## conditionals 1\n- statements are always executed in order, with three exceptions: functions, conditionals, and loops\n- indented lines = ‚Äúinside‚Äù functions\n- questions are often phrased as boolean expressions, while actions are written as statements\n- control flow diagrams are flowcharts for code ‚Äî visual representation of how the code should run\n    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/731bde24-deba-4995-813f-af455a4b9909/Untitled.png)\n- a boolean expression uses the `if` keyword and sometimes uses `else` if there are multiple solutions\n    ```python\n    if [boolean expression == True]:\n        # execute code\n    else: # implying that boolean expression == False\n        # execute different code\n    ```\n- *blocks* of code are defined by indentations (which come with colons)\n\n### downey ch4: case study: interface design\n\n- the `turtle` module in python allows you to create images with turtle graphics\n    - basically, it‚Äôs a little ‚Äúturtle‚Äù that you can control using commands (move forward, turn left) to draw stuff\n- `for` loops can be used to repeat pieces of code\n    ```python\n    for i in range(4):\n        print(i + \"hello!\")\n    \n    \u003e 0 hello!\n    \u003e 1 hello!\n    \u003e 2 hello!\n    \u003e 3 hello!\n    ```\n    - the `i` is a counter variable ‚Äî starting at 0, it will increase by 1 every loop\n    - `4` is the number of times the loop will repeat\n- **encapsulation** is when you wrap up code in a function\n    - this gives the code a name, which serves as documentation (noting what its purpose is)\n- **generalization** is adding parameters to a function to make it more ‚Äúcustomizable‚Äù, ex: creating a function that draws a square of *any* size instead of just 1 size\n- the **interface** of a function is a summary of how the function is used, including parameters, purpose, return values\n    - a good interface achieves its purpose without needing to provide unnecessary information\n- **refactoring** is the process of rearranging a program to improve interfaces ‚Äî the goal is to make the code more readable and still be useful\n- **docstrings** are strings at the top of a function that explains the interface (basically describes the purpose of the function)\n    - doc = documentation\n    - also called headers or javadoc comments in Java\n    - all docstrings are *triple-quoted*\n    ```python\n    def polyline(t, n, length, angle):\n        \"\"\"Draws n line segments with the given length and angle (in degrees) between them. t is a turtle.\"\"\"\n        for i in rage(n):\n            t.fd(length)\n            t.lt(angle)\n    ```\n- **preconditions** are things that are required to be true *before* the start of a function, ex: the `angle` parameter has to be a positive value\n- **postconditions** are conditions at the end of the function\n    - if the postconditions are wrong but the preconditions are satisfied, then the bug is within the function\n\n### downey ch5: conditionals ~~and recursion~~\n\n- the **floor division operator** (`//`) divides two numbers and returns the integer (rounds down), ex: `5 // 3 = 1`\n- the **modulus operator** (`%`) divides two numbers and returns the remainder, ex: `5 % 3 = 2`\n- a **boolean expression** will evaluate to either `True` or `False` and uses the `==` operator\n    - `!=` not equal to\n    - `\u003e` greater than\n    - `\u003c` less than\n    - `\u003e=` greater than or equal to\n    - `\u003c=` less than or equal to\n- **logical operators**: `and` `or` `not`\n- `if` statements are *conditional* statements, which check conditions\n    ```python\n    if x \u003e 0: \n        print(\"x is positive\")\n    ```\n    - if there is more than one possibility of the conditional statement, `else` clauses can be added\n        ```python\n        if x \u003e 0:\n            print(\"x is positive\")\n        else: \n            print(\"x is negative\")\n        ```\n    - if there are more than *two* possibilities, use `elif` to define other conditions\n        ```python\n        if x \u003e 0: \n            print(\"x is positive\")\n        elif x \u003c 0:\n            print(\"x is negative\")\n        else: \n            print(\"x is 0\")\n        ```\n- conditionals can also be nested inside each other ‚Äî the next example is a re-write of the previous one\n    ```python\n    if x \u003e 0:\n        print(\"x is positive\")\n    else:\n        if x \u003c 0:\n            print(\"x is negative\")\n        else:\n            print(\"x is 0\")\n    ```\n\n### downey ch6: fruitful functions\n\n- return values are usually assigned to variables or used in an expression\n    - if conditional statements are used, there can be multiple return statements ‚Äî it‚Äôs good practice to make sure the program can return a value no matter which path it takes\n- code that appears *after* a return statement is called **dead code** because it will never be executed\n- **incremental development** is the process of adding and debugging code in small chunks as to avoid long/complicated debugging sessions\n    - comments or tester pieces of code are called **scaffolding** which can be helpful for debugging, but aren‚Äôt part of the final product\n    - start with a working program and make small changes\n    - display intermediate values\n    - remove scaffolding to make code easier to read\n- one function can be called from within another\n- functions can return booleans\n    - common for the function name to be a yes/no question, like `is_even()`, `is_raining()`, or `is_divisible()`\n\n---\n\n## iteration 1\n\n- control flow diagram for a `while` loop\n    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4a1a4c52-ec6f-4480-8058-7ff5ee2afad7/Untitled.png)\n- basic code for a `while` loop\n    ```python\n    while [condition]:\n        # execute code\n    ```\n\n### ch7: iteration\n\n- **reassignment** is when an existing variable is updated to have a new value\n    - equality in python (and other languages) isn‚Äôt achieved through the `=` operator, ex: saying `a = 3` and `a = b` does not mean `b = 3`\n- an **update** is a specific type of reassignment where the new value is dependent on the old value\n    - **increments** are when a variable is updated by adding 1, **decrements** are when a variable is updated by subtracting 1\n- a variable has to be initialized (it has to exist) before it can be updated\n- repetition can be called **iteration**\n- `while` loops will execute as long as the condition remains true after each iteration\n    ```python\n    while n \u003e 0: # while n is greater than 0, display and decrement n\n        print(n)\n        n = n - 1\n    print(\"Blastoff!\")\n    ```\n    - an **infinite loop** is a loop that repeats forever, and occurs when there is no way for the condition to evaluate as false\n- `break` statements can be used to exit loops in the middle rather than at the beginning or end\n- an **algorithm** is a mechanical process for solving problems\n\n---\n\n## iteration 2\n\n- to repeat a loop `n` times, either use `i = 1` and `i \u003c= n` OR `i = 0` and `i \u003c n` because python starts counting from 0 and not 1\n- `break` immediately exits a loop, just like how `return` will immediately exit a function\n- the keyword `continue` will stop the *current iteration* and checks the condition to begin the next iteration\n- loops can be nested\n\n### sweigart ch2: flow control\n\ntodo\n\n---\n\n## strings\n\n- python can compare strings just like it can compare numbers with three edge cases: upper vs. lowercase, digits, prefixes\n    - uppercase always comes before lowercase, ex: `\"Z\"` \u003c `\"a\"`\n    - numbers in string form aren‚Äôt actual numbers, they are still considered strings and digits are compared to each place, ex: `\"100\"` \u003c `\"15\"`\n    - prefixes always come first, ex: `\"bat\"` \u003c `\"batman\"`\n- the `isDigit()` function returns if all the characters within a string are digits\n- a **method** is a special function that‚Äôs called on a variable or value, such as `isDigit()` or `upper()`, while functions pass variables or values as parameters\n    ```python\n    msg = \"hello\"\n    \n    msg.isDigit() # method\n    msg.upper() # method\n    \n    len(msg) # function\n    ```\n- **sequences** are collections of ordered values, such as strings, lists, or tuples\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/339192c7-8c57-4d5f-a57a-e8154e453e4c/Untitled.png)\n- **indexing** a string is when you access a value of the string, while **slicing** is taking a chunk of a string\n    - each character in the string has its own *index* value which is the number to call to retrieve that character\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/19fde618-53ae-4077-9d0f-879cdf859722/Untitled.png)\n- both `while` loops and `for` loops can be used to iterate through string\n    ```python\n    msg = \"hello\"\n    \n    # while loop\n    i = 0\n    while i \u003c len(msg):\n        letter = msg[i]\n        print(letter)\n        i += 1\n    \n    # for loop\n    for letter in msg:\n        print(letter)\n    ```\n- `for` loops can also have a *range* which is a way of telling the computer how many times the loop should be executed\n    ```python\n    for i in range(5): # will iterate 0 to 4\n        print(i * 3)\n    \n    \u003e 0\n    \u003e 3\n    \u003e 6\n    \u003e 9\n    \u003e 12\n    ```\n\n### downey ch8: strings\n\n- a string is a *sequence*\n- the **index** is a value that corresponds to a character within a sequence, ex: my sequence is `\"banana\"` and the value at index `1` is `\"a\"` (because python starts counting at 0)\n    - the index has to be an integer value\n- `len()` is a builtin function that returns the number of characters in a string\n- negative indices can be used to count backwards from a string, where the `-1` index returns the last character, `-2` index returns the second-to-last, etc\n- `for` loops can be used to traverse through strings, also called for-each loops\n    ```python\n    fruit = \"banana\"\n    \n    for letter in fruit: # the loop iterates from 0 to 5\n        print(letter)\n    \n    \u003e b # 0th index\n    \u003e a # 1st index\n    \u003e n # 2nd\n    \u003e a # 3\n    \u003e n # 4\n    \u003e a # 5\n    ```\n- string segments are called **slices** which can be obtained using the `[n:m]` operator where the operator includes the `n` letter but not the `m` value, ex: `fruit[1:4]` would return `\"ana\"`\n    - if the `n` is omitted, the slice starts at the beginning and ends at the `m` value, ex: `fruit[:4]` would return `\"bana\"`\n    - if the `m` is omitted, the slice starts at the `n` value and ends at the end of the string, ex `fruit[4:]` would return `\"na\"`\n    - a third argument can be used called *step size* which is the number of spaces between characters, ex: `fruit[0:5:2]` would return `\"bnn\"`\n        - `[start : end : step size]`\n- strings are **immutable** which means an existing string can‚Äôt be changed\n- a **counter** is a variable in a loop that starts at 0 and increments each time a condition is met ‚Äî sometimes the value of the counter is returned at the end of the loop\n- an **invocation** is when a *method* is called on an object, such as the `upper()` method, ex: `fruit.upper()` produces `\"BANANA\"`\n- the `find()` method can return the index where a substring (or character) starts, but it can also take an argument for which index in the string it starts looking at, ex: `fruit.find(\"na\")` produces `2`\n- the `in` operator for strings returns a boolean value if the substring is present in the string, ex: `\"a\" in \"banana\"` returns `True`\n- relational operators (`==`, `\u003c`, `\u003e`) work on strings and are used to put words in alphabetical order, but *all uppercase letters come before lowercase letters*\n\n### downey ch9: case study: word play\n\n- there is a built in function to read files ‚Äî `open( [filepath] )`\n- to read lines of the file, use `readline()`, which will read the next line of the file until it gets to the end of the file\n    - sometimes the lines will end with whitespace characters such as `\\r\\n` which we can get rid of by using the `strip()` function after the `readline()` function\n- the process of reading a file can be made easier by using a `for` loop\n- when testing programs, keep in mind **special cases** which are non-obvious cases that can produce errors, ex: what if a function is called on an empty string?\n\n\u003e Program testing can be used to show the presence of bugs, but never to show their absence! ‚ÄîEdsger W. Dijkstra\n\n---\n\n#\n\n## lists\n\n- a string is a sequence of characters ‚Äî a list is a sequence of anything!\n    - we can index, slice, and put lists in `for` loops and also use the `len()` function, concatenate with the `+` operator, use the `in` operator to find elements, and multiply by integers\n```python\n# using len()\nmsg = \"321go\"\nlen(msg)\n\u003e 5\n\n# concatenation\nmsg = \"321go\"\nmsg + \"!!!\"\n\u003e \"321go!!!\"\n\n# using in\nmsg = \"321go\"\n\"g\" in msg\n\u003e True\n\n# multiply by int\nmsg = \"321go\"\nmsg * 3\n\u003e \"321go321go321go\"\n```\n$\\phantom{-}$\n```python\n# using len()\nitems = [99,11,77,55]\nlen(items)\n\u003e 4\n\n# concatenation\nitems = [99,11,77,55]\nitems + [1,2,3]\n\u003e [99,11,77,55,1,2,3]\n\n# using in\nitems = [99,11,77,55]\n11 in items\n\u003e True\n\n# multiply by int\nitems = [99,11,77,55]\nitems * 2\n[99,11,77,55,99,11,77,55]\n```\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/79b3a7a1-78a8-4e62-87bd-4f474c97dd70/Untitled.png)\n\n### downey ch10: lists\n\n- a **list** is a *sequence*\n    - elements of a list, called **items**, can be of any type (unlike strings, where they have to be characters) ‚Äî they can even be different types than other elements within the same list\n- to create a new list, use square brackets to enclose the elements, ex: `cheeses = [\"Cheddar\", \"Gouda\", \"Mozzarella\", \"Swiss\"]`\n- lists within lists are called *nested* lists\n- empty lists don‚Äôt contain elements and can be created using empty brackets, ex: `empty = []`\n- the bracket operator `[]` can be used to access elements of a list (just like how brackets are used to access characters in a string), ex: `cheeses[1] = \"Gouda\"`\n    - lists are **mutable** which means that elements in the list can be changed\n- the `in` operator can be used on lists to find elements\n- when iterating through lists, the `in` operator will NOT update the elements in the list ‚Äî to update the elements, you have to use `range()` and `len()`\n    ```python\n    cheeses = [\"Cheddar\", \"Gouda\", \"Mozzarella\", \"Swiss\"]\n    \n    for cheese in cheeses: # will NOT change the cheeses list\n        cheese = \"eaten\"\n    \n    for i in range(len(cheese)): # WILL change the cheeses list\n        cheese[i] = \"eaten\"\n    ```\n- the `+` operator will join lists while the `*` operator will repeat a list a given number of times\n- list slicing works the same way as strings ‚Äî using the `[start : end : step size]` operator, sections of lists can be isolated\n- since lists are mutable, a good programming practice is to make a copy of the list before modifying it\n- list methods\n    - `append()` adds a new item to the end of the list\n    - `extend()` takes a list as an argument and adds the entire list to the main list\n    - `sort()` arranges the list elements from low to high\n    - `pop()` removes and returns the final element in a list, or it can remove and return the item at a specified index\n        - the `del` keyword accomplishes the same thing but without a return value\n    - `remove()` removes the item with the specified *value*\n        ```python\n        cheeses = [\"Cheddar\", \"Gouda\", \"Mozzarella\", \"Swiss\"]\n        \n        # the two statements below achieve the same purpose\n        cheeses.pop(1) # used if you know the index\n        cheeses.remove(\"Gouda\") # used if you know the value\n        ```\n- special types of operators\n    - **map** alter every element in a sequence\n    - **reduce** simplifies a sequence of elements into a single value\n    - **filter** removes some elements and returns others, usually according to a user-given rule\n- the `list()` function breaks a string into a list of characters, ex: `list(‚Äùhello‚Äù)` returns `['h', 'e', 'l', 'l', 'o']`\n- the `split()` function breaks a string into a list of words\n    - it can take a **delimiter** as an argument which is a specified boundary to split words\n        ```python\n        delimiter = \"-\"\n        str = \"spam-spam-spam\"\n        \n        str.split(delimiter) # produces [\"spam\", \"spam\", \"spam\"]\n        ```\n- the `join()` function joins a list into a string\n- two lists can be *equivalent*, meaning they have the same elements, but not *identical*, because they are referring to two different objects\n- identical ‚Üí equivalent, but equivalent does not mean identical\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6ba6099b-1184-413e-818c-d2fb25cee511/Untitled.png)\n- a variable assigned to an object is called a **reference**, and when an object has more than one reference, that means it is **aliased**\n    - if the aliased object is mutable, then any change will affect all aliases of the object\n- some operations (`append()` , `split()`, `[::]`) modify lists, while other operations (`+`, `*`) create new lists\n\n---\n\n## CSV tables\n\n- CSVs organize cells of data into rows and columns\n    - only holds strings and all text is plaintext\n- **delimiters** are characters that act as separators between objects ‚Äî for CSVs, the delimiter is a comma\n- when a CSV is opened in python, its result is a list of lists (or like a 2D array)\n\n### sweigart ch16: working with CSV files ~~and JSON data~~\n\n- CSV, comma-separated values, are simplified spreadsheets stored as plaintext ‚Äî supported by many types of programs and is very simple, exactly as advertised\n- each row in a CSV file represents a row in a spreadsheet, and each comma represents the next column\n- the `csv` module has a `reader` object which helps the user read the CSV file\n    ```python\n    import csv\n    exampleFile = open(\"example.csv\") # open the file\n    exampleReader = csv.reader(exampleFile) # \"reads\" the file and returns a reader object\n    exampleData = list(exampleReader) # converting data into list\n    \n    exampleData[0][0] # data at row 0, col 0\n    exampleData[0][1] # data at row 0, col 1\n    ```\n    - for larger CSV files, use a `for` loop and load one row at a time\n        ```python\n        for row in exampleReader: # iterating through reader object\n            str(row)\n            # execute code\n        ```\n\n---\n\n## dictionaries 1\n\n- a **data structure** is a collection of data values, their relationships, and the operations that can be applied to the data\n- **maps** associate values with labels and use labels to lookup values\n    - *lists* are maps which associate indices with values\n- dictionaries map labels (keys, not indices) to values ‚Äî keys must be immutable\n    ```python\n    nums_dict = {\"first\":900, \"second\":700, \"third\":800}\n    \n    nums_dict[\"third\"] # accessing 800\n    ```\n- reminder on parenthetical characters\n    - parentheses `()`: specifying order, calling functions\n    - brackets `[]`: creating lists, indexing, slicing, dictionary lookups\n    - braces `{}`: creating dictionaries, creating sets\n- use the `pop()` method to delete elements in the dictionary ‚Äî by default, `pop()` accepts keys\n- to add elements, assign keys to values using brackets like `d[20] = \"twenty\"`\n\n### downey ch11: dictionaries\n\n- dictionaries have **keys** and **values** which make up **items** ‚Äî each key is mapped to a value\n- create a new dictionary using the `dict()` function or two curly brackets `{}`\n    - add elements to a dictionary by using square brackets and assigning a value, ex: `nums[\"1\"] = \"one\"` where `nums` is the dictionary, `\"1\"` is the key, and `\"one\"` is the value\n- dictionaries are not ordered ‚Äî the only thing that matters is the key-value pairs stay the same\n- the `values()` method returns a collection of all the values\n- the `in` operator, `len()` function, and `sorted()` function all work on dictionaries\n- the `get()` method returns the corresponding value associated with a key ‚Äî if there is no value then it returns a default value\n\n---\n\n## dictionaries 2\n\n- create an empty dictionary `d = {}` or `d = dict()`\n- the `in` operator only checks if keys are present in the dictionary, it does not check for values\n- keys and values can be extracted and turned into lists using `list(d.keys())` or `list(d.values())`\n- use `get()` to return values, `pop()` to delete values in a dictionary and specify a default value if the key doesn‚Äôt exist\n- **bucketing/binning**: dictionary of lists\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0ee8ec20-6a81-4dbf-a2cd-51016624e43d/Untitled.png)\n- **table representation**: list of dictionaries\n- **probability tables/Markov chains**: dictionary of dictionaries\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/eba51788-fe9a-4e7f-beec-4c500aa586b5/Untitled.png)\n\n### downey ch11: dictionaries\n\n- a list can be a value in a dictionary, in other words, a list can be a value that is assigned to a key:value pair\n    - a list cannot be a key because the keys need to be hashable\n- a **singleton** is a list that contains a single element\n- a **hash** is a special function that takes values of any kind and returns and integer\n    - dictionaries use the integers (called hash values) to store key:value pairs\n    - hashes only work if the object is immutable (and lists aren‚Äôt immutable)\n- a **memo** is a dictionary that can be used to keep track of values that are already known\n    - when calculating the Fibonacci sequence, a memo can be used to store values that were already calculated\n- variables created outside functions are called **global variables** because they are located in the `__main__` frame\n- **flags**, boolean values for conditions, are usually global variables\n    - have to be declared within functions before they can be changed, ex: `global is_called` before using `is_called = !is_called`\n\n---\n\n## JSON\n\n- CSVs are good at storing list of lists, JSONs are good at storing dict of dicts\n\n### sweigart ch16: working with ~~CSV files and~~ JSON data\n\n- JSON, JavaScript Object Notation, stores information as JavaScript source code in plaintext files\n- application programming interface (API) is a way to bridge programs with their applications\n    - lets you scrape raw data from the website\n- the `json` module handles all the stuff between JSON data and python values using `json.loads()` and `json.dumps()` functions\n    - data can be read with the `loads()` function which will return the data as a dictionary\n    - data can be written with the `dumps()` function which can only take dictionary, list, int, float, string, Boolean, or `None` data types and will translate it into JSON data\n\n---\n\n## objects\n\n- using parentheses instead of brackets will create a tuple instead of a list\n    - like a list, `for` loops, indexing, slicing can be done\n- the `namedtuple` object can be imported and it will allow new types to be created\n    ```python\n    from collections import namedtuple\n    \n    Person = namedtuple(\"Person\", [\"fname\", \"lname\", \"age\"])\n    people = [\n        Person(\"Alice\", \"Anderson\", 30)\n        Person(\"Bob\", \"Baker\", 31)\n    ]\n    p = people[0]\n    print(\"Hello \" + p.fname + \" \" + p.lname)\n    \n    \u003e Hello Alice Anderson\n    ```\n- the mutable equivalent of a `namedtuple` is called a `recordclass`, ie: variables can be changed after they have been assigned\n- python uses separate references and objects because: 1) performance; 2) centralized updates\n- the `is` operator will return `True` when two references point to the same object, while the `==` operator only checks if the two objects are equivalent\n\n### downey ch10: lists\n\n- the `is` operator can tell you if two objects are equivalent and identical\n- identical implies equivalent, but equivalent does not imply identical\n\n### downey ch12: tuples\n\n- a tuple (too-ple) is an immutable list usually enclosed in parentheses ‚Äî create an empty one using `tuple()`\n    - can also refer to a group of objects in general\n- the bracket operator (for indexing) and slice operator `[::]` work on tuples\n- for relational operators (`\u003c`, `\u003e`, `=`) work by comparing each element of the tuple until there is a difference, and subsequent elements are not considered\n    - `(0, 1, 2) \u003c (0, 3, 4)`\n    - `(0, 1, 2000000) \u003c (0, 3, 4)`\n- tuples can be assigned in a special way\n    ```python\n    a, b = b, a\n    # tuple of variables on the left\n    # tuple of expressions on the right\n    ```\n    - the number of variables on the left side has to be equal to the number of expressions on the right side\n        ```python\n        addr = \"monty@python.org\"\n        uname, domain = addr.split(\"@\")\n        ```\n- a parameter that begins with `*` will **gather** all arguments into a tuple\n    ```python\n    def printall(*args):\n        print(args)\n    \n    printall(1, 2.0, \"3\") # combines all arguments into tuple\n    ```\n- an argument that uses the `*` operator on a tuple will break the tuple (**scatter**) into multiple arguments (so the opposite of a *gather*)\n    ```python\n    t = (7, 3)\n    divmod(*t) # breaks t into 2 arguments\n    ```\n- the `zip()` function takes multiple sequences and returns a list of tuples where each tuple has an element from each sequence\n    - the zip object is an **iterator** which means that it‚Äôs an object that iterates (moves through) a sequence ‚Äî usually has a `.next()` and no indices\n    ```python\n    s = \"abc\"\n    t = [0, 1, 2]\n    zip(s,t) # creates a zip object\n    \n    for pair in zip(s,t):\n        print(pair)\n    \n    \u003e (\"a\", 0)\n    \u003e (\"b\", 1)\n    \u003e (\"c\", 2)\n    ```\n    - if the sequences are different lengths, the zip object ends when the first sequence ends\n    - this is very useful for traversing through multiple sequences at the same time\n- the `enumerate()` function creates an enumerate object, or a sequence of pairs matching an index to an element in the argument\n    ```python\n    for index, element in enumerate(\"abc\"):\n        print(index, element)\n    \n    \u003e 0 a\n    \u003e 1 b\n    \u003e 2 c\n    ```\n- dictionaries have a method called `items()` that returns a sequence of tuples of key:value pairs\n- a list of tuples can be initialized into a new dictionary using `dict()`\n- tuples are commonly used as keys in dictionaries because lists can‚Äôt be used as dictionaries (tuples are immutable, lists are not)\n\n---\n\n## copying\n\n- slicing creates a new object\n- three levels of copying\n    - reference copy (0 levels): fastest but most dangerous, only creates a pointer to the object ‚Äî any changes to either object will change both\n    - shallow copy (1 level): used to copy an object (ie, a list) so the original doesn‚Äôt get corrupted, but it only makes a new object (a new list) that refers to the same original objects\n        - helpful for reorganizing object positions like sorting a list or dictionary, but not helpful if you want to change values\n    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/06296c4e-8763-4d8a-9502-b94be7f9b455/Untitled.png)\n    - deep copy (all levels): slowest but the safest, copies everything including sub-lists and sub-dictionaries ‚Äî any changes made in the copy is not reflected in the original\n\n### sweigart ch4: lists\n\n- when assigning lists to variables, a *reference* to the list is what‚Äôs stored, not the actual list itself\n    - so if two variables point to the same list, then any change made on one variable will reflect on the other\n- python uses **references** when storing values of mutable types, like lists or dictionaries; it will store actual values for immutable types like strings, ints, or tuples\n    - even though lists and dictionaries are passed by reference through functions, they will still be altered directly\n- the `copy` module provides a `copy()` and `deepcopy()` function that makes duplicate copies of dictionaries or lists (and not just references)\n    - if the copy contains lists, use `deepcopy()` because it will copy inner lists\n\n---","lastmodified":"2022-07-06T21:15:13.452172199Z","tags":null},"/stream":{"title":"Stream","content":"This serves as a hub for all of my recent edits on my website. All of my writing is organized into three categories ‚Äî **seed** (üå∞) for quick thoughts, **leaf** (üåø) for revised ideas, and **fruit** (ü•≠) for completed blog posts.\n\n- üåø 22-06-26 `::` [NOTES - CS 220: Data Programming I](/notes/cs220.md)\n- ü•≠ 22-06-26 `::` [Summer Exploration Arc #2](/2022-sea2.md)\n- ü•≠ 22-06-11 `::` [Summer Exploration Arc #1](/2022-sea1.md)","lastmodified":"2022-07-06T21:15:13.452172199Z","tags":null}}