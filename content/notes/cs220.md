---
title: "CS 220: Data Programming I"
---
Self-paced course taken summer '22, linked [here](https://www.msyamkumar.com/cs220/s20/syllabus.html). Introductory data science programming using Python focusing on analyzing data quickly and efficiently.

## introduction
- inputs: keyboard, mouse
- outputs: monitor, speaker
- devices attach to the computer via “ports” (USB)
- motherboard: main circuit and connects to other components with sockets and slots
- CPU, central processing unit
    - runs code (receives input, sends output)
    - runs on a clock, measured in Hz (ex. GHz is billions of ticks per second)
    - high speed CPU → hotter
    - computers have multiple CPUs
- RAM, random access memory
    - short term data storage
        - CPU sends to and from RAM
    - “volatile” - lose data when computer is powered off
    - one byte = one letter
- storage drives
    - HDD, hard disk drive
        - inexpensive, moving parts, slow
    - SSD, solid state drive
        - expensive, no moving parts, fast
    - stores data after computer shut down
- network: an extension or built-in card to the motherboard
    - NIC, network interface controller
        - provides communication to other machines + internet
    - wired = ethernet, wireless = wifi
    - server: computer waits for incoming requests which it responds to
    - client: program that sends requests to a server
- jupyter notebook runs and displays results of py code without needing to run it yourself

---

## the terminal

- you can connect to terminals located anywhere, such as connecting to a remote computer OR connecting to a personal computer
- shell helps navigate to program and run
- helpful shell commands    
    - `pwd` get working directory → current location
    - `man` opens manual pages for command
    - `<tab>` autocomplete
    - `<ctrl-C>` kill / exit
    - `<up arrow>` last used command
    - `<ctrl-R>` search used commands
    - `cd` open directory
        - `cd ..` go up a directory
        - `cd /` go to top directory
    - `ls` lists contents of current directory
    - `mkdir` makes new directory
    - `echo` repeat or copy
    - `cat` display contents of file
    - `mv [original] [destination]` move files
    - `cp [original] [destination]` copy files        
- pathname: the location of your file (windows: includes drive letter, filename, extension…)
    - absolute: always possible (complete path name to file)
    - relative: with respect to current location
    - working directory: current location
    - `..` navigates up a directory
    - `.` navigates into a directory
- arguments are inputs that come after the call of the program name
- use `>` to redirect output to a new file
- use `>>` to add output to a file

---

## programming

- interpreter: a program that translates human-legible code into machine-legible code
- editor: a program where you can write code
- jupyter notebook mixes code with other things like images, tables, documentation, etc
- ways to run python
    - `python` interactive, denoted by `>>>`
    - `python [program name]` script
    - `jupyter notebook` notebook
- python uses order of operations to simplify equations (parentheses, exponents, m/d, a/s)
    - negative and positive signs take precedence over m/d
    - logic operators come after comparison operators which come after math operators

![diagram](/images/operator-precedence.png)

- boolean operators
    - AND: true when both conditions are true (t/t), false otherwise (t/f, f/t, f/f)
    - OR: true when one condition is true (t/t, t/f, f/t), false otherwise (f/f)
    - NOT: true when the condition is false
        - evaluate: NOT(is it saturday?)
            - if (is it saturday?) is true, then the expression is false, i.e., it IS saturday
            - if (is it saturday?) is false, then the expression is true, i.e., it is NOT saturday

### ch1: the way of the program

- python uses symbols as *bitwise* operators and words as logic operators
    - `and` `or` are logic operators
    - `&` `|` are bitwise operators
        - convert arguments into binary before comparisons
- common types: int, float, string, boolean
- parsing is understanding structure and meaning in a language
    - formal language: specifically designed languages (like mathematical or molecular notation); means exactly what it says, unambiguous, less redundant/more concise
    - natural language: naturally-evolved language (like English); has idioms/metaphor, needs redundancy to make up for ambiguity

---

## variables and expressions

- expressions are a mix of operators (logic, mathematical) and operands (values)
    - an operand *could* be a variable which means it won’t be a fixed value
    - `//` is the floor division operator: `x // y` is “how many times does `y` go into `x`?
- assignments compute an expression and put the result in a variable — assignment operator is `=`
    - ex: `total = x+y` where `total` is the resultant variable; `x` and `y` are operands (and also variables); `x+y` is the expression
- types of errors
    - syntax error: the written code is wrong, Python won’t run, ex: `5 = x`, we can’t assign `x` to the number `5`
    - runtime errors: something that crashes when we run the code, ex: `x = 5 / 0`, can’t divide by zero and will result in a `ZeroDivisionError`
    - semantic (logic) error: the code runs but you don’t get the result you want
- python variable naming conventions
    - don’t use keywords
        |     |     |     |     |     |     |     | 
        | --- | --- | --- | --- | --- | --- | --- |
        | False | assert | del | for | in | or | while |
        | None | break | elif | from | is | pass | with |
        | True | class | else | global | lambda | raise | yield |
        | and | continue | except | if | nonlocal | return |  |
        | as | def | finally | import | not | try |  |
    - don’t name your variable after a type, like `int` or `str`
    - only use letters (upper + lower), numbers, underscores
        - don’t start the variable name with a number
    
    | examples | nonexamples |
    | --- | --- |
    | CS220 | 220class |
    | cs_220 | x! |
    | _cs220 | pi3.14 |

### ch2: variables, expressions and statements

- python conventionally uses lowercase and underscores for variable names
    - illegal names will cause syntax errors
- python code can be saved into files called *scripts* which end with `.py`
- `print()` needs to be used in script mode if you want to display outputs
- PEMDAS is helpful for remembering the order of operation for expressions
    - **P**arentheses, **E**xponents, **M**ultiplication and **D**ivision, **A**ddition and **S**ubtraction
- can’t perform mathematical operations on strings but we *can* add strings together (called string concatenation)
    ```python
    first = 'throat'
    second = 'warbler'
    print(first + second)
    > throatwarbler
    ```
- strings can also be multiplied, ex: `'Spam'*3` is `'SpamSpamSpam'`
- comments are lines that the computer will ignore — used to make notes between lines of code for humans to read
    ```python
    # compute percentage of an hour
    percentage = (minute * 100) / 60
    ```
    - everything on the line with the `#` symbol is ignored
    - usually used to denote things that aren’t obvious to the reader — meanings of variables, functions
- syntax errors appear *before* the program is run; runtime errors appear *after* the program has run; semantic errors don’t appear at all

---

## using functions

- functions are “mini-programs” or small steps that can build a big program
- refactoring is when the code is reorganized
- **parameters** are variables that receive a function’s input
- **arguments** are values that are sent to a function
    - default arguments are values that are sent to the function *if* no custom value is provided
- **return values** are outputs from the function

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/67c58043-cd64-44c3-8674-953c2dd46f0b/Untitled.png)

- calling a function in python: `[fnc name]([arguments])` ex: `print("hello")` where `print` is the function name, followed by parentheses, and `"hello"` is the argument

### ch3: functions

- **function** - a named sequence that performs a computation
- python has *modules* which are prewritten code that you can use in your program by importing
    - ex: functions from the math module can be used after importing it with `import math`, including `math.sin()`, `math.log10(), etc`
- functions can be called using *dot notation* which is the format `[module name].[function name]`
- variables are always on the left side of an assignment operator

---

## creating functions

- math to python example
    $f(x)=x^2$
    `def f(x):
        return x ** 2`
    - both functions are called `f` and take a parameter, `x`, and return the value of `x` squared
- indentation is important in python!
    - following the colon after the first line of a function, all following lines are indented 4 spaces
- filling parameters
    - positional arguments — arguments assigned by position
        ```python
        def foo(x, y = -1):
            x = [] # this would be 99, because 99 is the first arg
    	    y = [] # this would be 100

        foo(99, 100)
        ```
    - keyword arguments — arguments assigned to variable names
        ```python
        def foo(x, y = -1):
            x = [] # this would be 100 because we said x=100 below
            y = [] # this would be 99
        
        foo(y=99, x=100)
        ```
    - default arguments — inserted arguments if nothing is provided
        ```python
        def foo(x, y = -1):
            x = [] # this would be 99 
            y = [] # this would be -1 because we specified it above
        
        foo(99)
        ```
- `return` will provide code to the program that can be used later, while `print()` will output the code to a terminal

### ch3 (cont.): functions

- custom functions can be added by using the keyword `def`
    - the **header** of the function is the first line, while the **body** **(indented 4 spaces) is the rest of the function
- if the parentheses after the function name are empty, that means the function doesn’t take any arguments
    ```python
    def foo():
        print(36)
    
    foo()
    > 36
    ```
- functions have to be created before they can be called → function definitions are always at the top of a program
    - execution begins at the top of the program and moves down
- *fruitful functions* return values; *void functions* don’t return anything
    - usually want to perform an action with the output of a fruitful function

### reading: creating fruitful functions

- to send a value to a variable instead of printing it to a screen, we can use the `return` keyword → is called a fruitful function
    - result is stored in a variable and can be used again
    ```python
    # using print
    def get_name(first, last):
        print(first + " " + last)
    
    name = get_name("Jane", "Doe")
    > "Jane Doe"
    
    print(name)
    > None # nothing is assigned to 'name' so it has the None type
    ```  
    $\phantom{-}$
    ```python
    # using return
    def get_name(first, last):
        return(first + " " + last)
    
    name = get_name("Jane", "Doe") # nothing prints because there is no print statement
    
    print(name)
    > "Jane Doe" # the name is returned through the function
    ```
- once a `return` statement is reached, the function ends
    ```python
    # using print()
    def countdown_print():
        print(3)
        print(2)
        print(1)
    
    countdown_print()
    > 3
    > 2
    > 1
    ```
    $\phantom{-}$
    ```python
    # using return
    def countdown_return():
        return 3
        return 2
        return 1
    
    countdown_return()
    > 3
    ```
- `__builtins__` is a special module that is already imported
- `dir()` lists all functions that are part of a module
- `.__doc__` returns the documentation of a function
    ```python
    import math

    print(math.log.__doc__) # [module name].[function name].__doc__
    > log(x, [base=math.e])
    > Return the logarithm of x to the given value
    ```