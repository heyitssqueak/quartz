---
title: "CS 220: Data Programming I"
---
Self-paced course taken summer '22, linked [here](https://www.msyamkumar.com/cs220/s20/syllabus.html). Introductory data science programming using Python focusing on analyzing data quickly and efficiently.

## introduction
- inputs: keyboard, mouse
- outputs: monitor, speaker
- devices attach to the computer via “ports” (USB)
- motherboard: main circuit and connects to other components with sockets and slots
- CPU, central processing unit
    - runs code (receives input, sends output)
    - runs on a clock, measured in Hz (ex. GHz is billions of ticks per second)
    - high speed CPU → hotter
    - computers have multiple CPUs
- RAM, random access memory
    - short term data storage
        - CPU sends to and from RAM
    - “volatile” - lose data when computer is powered off
    - one byte = one letter
- storage drives
    - HDD, hard disk drive
        - inexpensive, moving parts, slow
    - SSD, solid state drive
        - expensive, no moving parts, fast
    - stores data after computer shut down
- network: an extension or built-in card to the motherboard
    - NIC, network interface controller
        - provides communication to other machines + internet
    - wired = ethernet, wireless = wifi
    - server: computer waits for incoming requests which it responds to
    - client: program that sends requests to a server
- jupyter notebook runs and displays results of py code without needing to run it yourself

---

## the terminal

- you can connect to terminals located anywhere, such as connecting to a remote computer OR connecting to a personal computer
- shell helps navigate to program and run
- helpful shell commands    
    - `pwd` get working directory → current location
    - `man` opens manual pages for command
    - `<tab>` autocomplete
    - `<ctrl-C>` kill / exit
    - `<up arrow>` last used command
    - `<ctrl-R>` search used commands
    - `cd` open directory
        - `cd ..` go up a directory
        - `cd /` go to top directory
    - `ls` lists contents of current directory
    - `mkdir` makes new directory
    - `echo` repeat or copy
    - `cat` display contents of file
    - `mv [original] [destination]` move files
    - `cp [original] [destination]` copy files        
- pathname: the location of your file (windows: includes drive letter, filename, extension…)
    - absolute: always possible (complete path name to file)
    - relative: with respect to current location
    - working directory: current location
    - `..` navigates up a directory
    - `.` navigates into a directory
- arguments are inputs that come after the call of the program name
- use `>` to redirect output to a new file
- use `>>` to add output to a file

---

## programming

- interpreter: a program that translates human-legible code into machine-legible code
- editor: a program where you can write code
- jupyter notebook mixes code with other things like images, tables, documentation, etc
- ways to run python
    - `python` interactive, denoted by `>>>`
    - `python [program name]` script
    - `jupyter notebook` notebook
- python uses order of operations to simplify equations (parentheses, exponents, m/d, a/s)
    - negative and positive signs take precedence over m/d
    - logic operators come after comparison operators which come after math operators

![diagram](/images/operator-precedence.png)

- boolean operators
    - AND: true when both conditions are true (t/t), false otherwise (t/f, f/t, f/f)
    - OR: true when one condition is true (t/t, t/f, f/t), false otherwise (f/f)
    - NOT: true when the condition is false
        - evaluate: NOT(is it saturday?)
            - if (is it saturday?) is true, then the expression is false, i.e., it IS saturday
            - if (is it saturday?) is false, then the expression is true, i.e., it is NOT saturday

### ch1: the way of the program

- python uses symbols as *bitwise* operators and words as logic operators
    - `and` `or` are logic operators
    - `&` `|` are bitwise operators
        - convert arguments into binary before comparisons
- common types: int, float, string, boolean
- parsing is understanding structure and meaning in a language
    - formal language: specifically designed languages (like mathematical or molecular notation); means exactly what it says, unambiguous, less redundant/more concise
    - natural language: naturally-evolved language (like English); has idioms/metaphor, needs redundancy to make up for ambiguity

---

## variables and expressions

- expressions are a mix of operators (logic, mathematical) and operands (values)
    - an operand *could* be a variable which means it won’t be a fixed value
    - `//` is the floor division operator: `x // y` is “how many times does `y` go into `x`?
- assignments compute an expression and put the result in a variable — assignment operator is `=`
    - ex: `total = x+y` where `total` is the resultant variable; `x` and `y` are operands (and also variables); `x+y` is the expression
- types of errors
    - syntax error: the written code is wrong, Python won’t run, ex: `5 = x`, we can’t assign `x` to the number `5`
    - runtime errors: something that crashes when we run the code, ex: `x = 5 / 0`, can’t divide by zero and will result in a `ZeroDivisionError`
    - semantic (logic) error: the code runs but you don’t get the result you want
- python variable naming conventions
    - don’t use keywords
        |     |     |     |     |     |     |     | 
        | --- | --- | --- | --- | --- | --- | --- |
        | False | assert | del | for | in | or | while |
        | None | break | elif | from | is | pass | with |
        | True | class | else | global | lambda | raise | yield |
        | and | continue | except | if | nonlocal | return |  |
        | as | def | finally | import | not | try |  |
    - don’t name your variable after a type, like `int` or `str`
    - only use letters (upper + lower), numbers, underscores
        - don’t start the variable name with a number
    
    | examples | nonexamples |
    | --- | --- |
    | CS220 | 220class |
    | cs_220 | x! |
    | _cs220 | pi3.14 |

### ch2: variables, expressions and statements

- python conventionally uses lowercase and underscores for variable names
    - illegal names will cause syntax errors
- python code can be saved into files called *scripts* which end with `.py`
- `print()` needs to be used in script mode if you want to display outputs
- PEMDAS is helpful for remembering the order of operation for expressions
    - **P**arentheses, **E**xponents, **M**ultiplication and **D**ivision, **A**ddition and **S**ubtraction
- can’t perform mathematical operations on strings but we *can* add strings together (called string concatenation)
    ```python
    first = 'throat'
    second = 'warbler'
    print(first + second)
    > throatwarbler
    ```
- strings can also be multiplied, ex: `'Spam'*3` is `'SpamSpamSpam'`
- comments are lines that the computer will ignore — used to make notes between lines of code for humans to read
    ```python
    # compute percentage of an hour
    percentage = (minute * 100) / 60
    ```
    - everything on the line with the `#` symbol is ignored
    - usually used to denote things that aren’t obvious to the reader — meanings of variables, functions
- syntax errors appear *before* the program is run; runtime errors appear *after* the program has run; semantic errors don’t appear at all

---

## using functions

- functions are “mini-programs” or small steps that can build a big program
- refactoring is when the code is reorganized
- **parameters** are variables that receive a function’s input
- **arguments** are values that are sent to a function
    - default arguments are values that are sent to the function *if* no custom value is provided
- **return values** are outputs from the function

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/67c58043-cd64-44c3-8674-953c2dd46f0b/Untitled.png)

- calling a function in python: `[fnc name]([arguments])` ex: `print("hello")` where `print` is the function name, followed by parentheses, and `"hello"` is the argument

### ch3: functions

- **function** - a named sequence that performs a computation
- python has *modules* which are prewritten code that you can use in your program by importing
    - ex: functions from the math module can be used after importing it with `import math`, including `math.sin()`, `math.log10(), etc`
- functions can be called using *dot notation* which is the format `[module name].[function name]`
- variables are always on the left side of an assignment operator

---

## creating functions

- math to python example
    $f(x)=x^2$
    `def f(x):
        return x ** 2`
    - both functions are called `f` and take a parameter, `x`, and return the value of `x` squared
- indentation is important in python!
    - following the colon after the first line of a function, all following lines are indented 4 spaces
- filling parameters
    - positional arguments — arguments assigned by position
        ```python
        def foo(x, y = -1):
            x = [] # this would be 99, because 99 is the first arg
    	    y = [] # this would be 100

        foo(99, 100)
        ```
    - keyword arguments — arguments assigned to variable names
        ```python
        def foo(x, y = -1):
            x = [] # this would be 100 because we said x=100 below
            y = [] # this would be 99
        
        foo(y=99, x=100)
        ```
    - default arguments — inserted arguments if nothing is provided
        ```python
        def foo(x, y = -1):
            x = [] # this would be 99 
            y = [] # this would be -1 because we specified it above
        
        foo(99)
        ```
- `return` will provide code to the program that can be used later, while `print()` will output the code to a terminal

### ch3 (cont.): functions

- custom functions can be added by using the keyword `def`
    - the **header** of the function is the first line, while the **body** **(indented 4 spaces) is the rest of the function
- if the parentheses after the function name are empty, that means the function doesn’t take any arguments
    ```python
    def foo():
        print(36)
    
    foo()
    > 36
    ```
- functions have to be created before they can be called → function definitions are always at the top of a program
    - execution begins at the top of the program and moves down
- *fruitful functions* return values; *void functions* don’t return anything
    - usually want to perform an action with the output of a fruitful function

### reading: creating fruitful functions

- to send a value to a variable instead of printing it to a screen, we can use the `return` keyword → is called a fruitful function
    - result is stored in a variable and can be used again
    ```python
    # using print
    def get_name(first, last):
        print(first + " " + last)
    
    name = get_name("Jane", "Doe")
    > "Jane Doe"
    
    print(name)
    > None # nothing is assigned to 'name' so it has the None type
    ```  
    $\phantom{-}$
    ```python
    # using return
    def get_name(first, last):
        return(first + " " + last)
    
    name = get_name("Jane", "Doe") # nothing prints because there is no print statement
    
    print(name)
    > "Jane Doe" # the name is returned through the function
    ```
- once a `return` statement is reached, the function ends
    ```python
    # using print()
    def countdown_print():
        print(3)
        print(2)
        print(1)
    
    countdown_print()
    > 3
    > 2
    > 1
    ```
    $\phantom{-}$
    ```python
    # using return
    def countdown_return():
        return 3
        return 2
        return 1
    
    countdown_return()
    > 3
    ```
- `__builtins__` is a special module that is already imported
- `dir()` lists all functions that are part of a module
- `.__doc__` returns the documentation of a function
    ```python
    import math

    print(math.log.__doc__) # [module name].[function name].__doc__
    > log(x, [base=math.e])
    > Return the logarithm of x to the given value
    ```

---

## function scope

- variable names can be organized in *frames*
- **frames** are created when a function is called — parameters and variables exist in the frame (also called scope?)
    ```python
    def print_twice(s): # function frame
    		print(s)
    		print(s)
    
    def cat_twice(p1, p2): # different function frame
    		cat = p1 + p2
    		print_twice(cat)
    
    line1 = "bing bong" # lies in the global frame
    line2 = "bong bing" # lies in the global frame
    cat_twice(line1, line2)
    ```
    - the module can access two variables: `line1` and `line2`
    - `cat_twice()` accesses three variables: `p1` (which is `line1` passed through the function), `p2` (which is `line2` passed through the function), and `cat`
    - `print_twice()` only accesses one variable: `s` which is `cat` passed through
- local variables
    - functions don’t execute unless they’re called
        ```python
        def set_x():
        		x = 100
        
        print(x)
        # doesn't print anything because set_x() wasn't called
        ```
    - variables created in a function die after the function returns
        ```python
        def set_x():
        		x = 100
        
        set_x()
        print(x)
        # doesn't print because x doesn't exist after the end of the function
        ```
    - variables are reset every time a function is called
    - variables aren’t shared across functions
        ```python
        def display():
        		print(x)
        
        def main():
        		x = 100
        		display()
        
        main()
        ```
        - even though `x` is set to be `100` in the `main()` function, the `display()` function can’t see the `x` value and it doesn’t print anything
- global variables can be used inside functions
    - python assumes any variables assigned within functions are *local variables*
        ```python
        msg = "hello"
        
        def greeting():
        		msg = "welcome!" # local variable, only present within the function
        		print("greeting: " + msg)
        
        print("before: " + msg) 
        greeting()
        print("after: " + msg)
        
        > before: hello
        > greeting: welcome!
        > after: hello
        ```
- use `global [var name]` to declare when to create a global variable
    ```python
    msg = "hello"
    
    def greeting():
    			global msgd
    		msg = "welcome!" # local variable, only present within the function
    		print("greeting: " + msg)
    
    print("before: " + msg) 
    greeting()
    print("after: " + msg)
    
    > before: hello
    > greeting: welcome!
    > after: welcome!
    ```
- python arguments are “passed by value” meaning any change to an argument that happens inside a function does *not* apply to that variable outside of the function
- the argument and parameter can have the same (or different) name

### ch3 (cont.): functions

- inside a function, arguments are assigned to variables called *parameters*
- variables created inside functions exist only in that function
- a **traceback** is a list of functions that details what file, line, and functions caused an error
- usefulness of functions
    - repetitive code can be named and grouped, which makes debugging easier
    - reusuable
- Linux started out as a program that would switch between printing `AAAA` and `BBBB`

---

## conditionals 1

### ch4: case study: interface design

- the `turtle` module in python allows you to create images with turtle graphics
    - basically, it’s a little “turtle” that you can control using commands (move forward, turn left) to draw stuff
- `for` loops can be used to repeat pieces of code
    ```python
    for i in range(4):
    		print(i + "hello!")
    
    > 0 hello!
    > 1 hello!
    > 2 hello!
    > 3 hello!
    ```
    - the `i` is a counter variable — starting at 0, it will increase by 1 every loop
    - `4` is the number of times the loop will repeat
- **encapsulation** is when you wrap up code in a function
    - this gives the code a name, which serves as documentation (noting what its purpose is)
- **generalization** is adding parameters to a function to make it more “customizable”, ex: creating a function that draws a square of *any* size instead of just 1 size
- the **interface** of a function is a summary of how the function is used, including parameters, purpose, return values
    - a good interface achieves its purpose without needing to provide unnecessary information
- **refactoring** is the process of rearranging a program to improve interfaces — the goal is to make the code more readable and still be useful
- **docstrings** are strings at the top of a function that explains the interface (basically describes the purpose of the function)
    - doc = documentation
    - also called headers or javadoc comments in Java
    - all docstrings are *triple-quoted*
    ```python
    def polyline(t, n, length, angle):
    		"""Draws n line segments with the given length and angle (in degrees) between them. t is a turtle."""
    		for i in rage(n):
    				t.fd(length)
    				t.lt(angle)
    ```
- **preconditions** are things that are required to be true *before* the start of a function, ex: the `angle` parameter has to be a positive value
- **postconditions** are conditions at the end of the function
    - if the postconditions are wrong but the preconditions are satisfied, then the bug is within the function

### ch5: conditionals ~~and recursion~~

- the **floor division operator** (`//`) divides two numbers and returns the integer (rounds down), ex: `5 // 3 = 1`
- the **modulus operator** (`%`) divides two numbers and returns the remainder, ex: `5 % 3 = 2`
- a **boolean expression** will evaluate to either `True` or `False` and uses the `==` operator
    - `!=` not equal to
    - `>` greater than
    - `<` less than
    - `>=` greater than or equal to
    - `<=` less than or equal to
- **logical operators**: `and` `or` `not`
- `if` statements are *conditional* statements, which check conditions
    ```python
    if x > 0: 
    		print("x is positive")
    ```
    - if there is more than one possibility of the conditional statement, `else` clauses can be added
        ```python
        if x > 0:
        		print("x is positive")
        else: 
        		print("x is negative")
        ```
    - if there are more than *two* possibilities, use `elif` to define other conditions
        ```python
        if x > 0: 
        		print("x is positive")
        elif x < 0:
        		print("x is negative")
        else: 
        		print("x is 0")
        ```
- conditionals can also be nested inside each other — the next example is a re-write of the previous one
    ```python
    if x > 0:
    		print("x is positive")
    else:
    		if x < 0:
    				print("x is negative")
    		else:
    				print("x is 0")
    ```